(include "compiler.bkl")

(define T-env
  (lambda (code expected root-env)
    (set! code (DI! code [code]))
;    (when (nil? env) (set! env [{} []]))
    (let ((r (bukalisp-compile "tests" code root-env #f)))
;      (displayln ROOT_ENV: (pp-str root-env))
;      (pp-str root-env)
      (if (eqv? (write-str r) (write-str expected))
        (displayln (str "OK - " code))
        (error (str "Test failed: " code ", returned: " r " != " expected))))))

(define T
  (lambda (code expected)
    (T-env code expected {})))
;----------------------------------------------------------------------------

;(PUSH-DEBUG)

;(error X:)
;----------------------------------------------------------------------------

;(PUSH-DEBUG)
;(T '((lambda (x y)
;       (+ 1 ((lambda () x))))
;     5 nil)
;   6)
;(error XXX:)
;
;(PUSH-DEBUG)
;;(POP-DEBUG)
;;(error XFFF:)
;(T '(begin
;  (define x 0)
;  (for (i 1 100000000)
;    (set! x (+ x 1))))
;   100000000)
;(T '(begin
;  (define x 0)
;  (for (i 1 100000000)
;    (set! x (+ x 1))))
;   100000000)
;;(error o:)
;;(T '(begin
;;  (define x 0)
;;  (define (inc a) (set! x (+ x a)))
;;  (for (i 1 10000000)
;;    (inc 1)))
;;   10000000)
;;;;
;;;(error F:)
;(T '(let ((x 100000000))
;      (while (> x 0)
;             (set! x (- x 1)))) 0)
;(T '(begin
;      (define x 100000000)
;      (while (> x 0)
;             (set! x (- x 1)))) 0)
;
;;(PUSH-DEBUG)
;;(T '(let ((x 0))
;;      (define (o a b) x)
;;      (o 1 2)
;;      [x])
;;   [100000 5000050000])
;(error X:)
;----------------------------------------------------------------------------

; Test basic (lambda ...) and (let ...)
(T '((lambda (y)
       (let ((x 10))
         (+ x y)))
     13)
   23)

(T '(begin
      (define x 5)
      (+ 1 2 x))
   8)

(T '((lambda (x) (+ x 10)) 11)
   21)

(T '((lambda ()
       (define z 10))) 10)

; Test more basic things:
(T '(+ 1 2 3 4 5 6) 21)

(T '(begin
      (+ 1 123)
      (+ 1 345)
      (+ 1 567))
   568)

(T '(begin 123) 123)
(T '(+ 123)     123)
(T '(+ 1 123)   124)
(T '(begin
      (define x 12)
      (define y 34)
      (+ x y))
   46)
(T '(begin
      (define x 12)
      (define y 34)
      (+ x y))
   46)
(T '(begin
      (define x 12)
      (set! x (+ 14.5 x)))
   26.5)
(T '(begin
      (define x +)
      (set! x (x 1.5 1)))
   2.5)

(T '(* 2 3 4)          24)

(T '(> (atom-id []) 0) #true)

; Test var-args:
(T '((lambda (. x) x) 1 2 3) '(1 2 3))

(T '((lambda (. x) x))              [])
(T '((lambda (. x) x) 1 2 3)        [1 2 3])
(T '((lambda (a . x) [a x]) 1 2 3)  [1 [2 3]])
(T '((lambda (a . x) [a x]) 1)      [1 []])
(T '((lambda (a . x) [a x]) nil)    [nil []])
(T '(begin
      (define (x a . v) [a v])
      (x 1 2 3))
   [1 [2 3]])

; Test upvalues and closures
(T '((lambda (x) x) 5)
   5)

(T '((lambda (x y)
       (+ 1 ((lambda () x))))
     5 nil)
   6)

(T '((lambda (x)
       ((lambda (y) (+ x y))
        10))
     5)
   15)

(T '(begin (define x 0)
           (define (o a)
             (set! x (+ x a)))
           (for (i 1 1000000)
             (o 1)))
   1000000)

(T '((((let ((x 10))
         (lambda (y)
           (lambda (j)
             (let ((v (+ y j x)))
               (lambda ()
                 (+
                   ((lambda () (+ v x)))
                   v
                   x
                   j
                   y)))))) 1) 2))
   49)

; Test weird (define ...)s:
(T '(let ((x (begin
               (define y 20)
               (+ 10 y))))
      (define o 20)
      (+ y x o))
   70)
(T '(let ((x 1))
      (define o 10)
      (+ o x))
   11)

; Test (for ...), upvalues and closures:
(T '(begin (define x 0)
           (define (o a)
             (set! x (+ x a)))
           (for (i 1 1000000)
             (o 1)))
   1000000)

(T '(let ((x 0))
      (define (o a)
        (set! x (+ x a)))
      (for (i 1 1000000)
        (o 1)))
   1000000)

(T '(let ((x 0)
          (y 0))
      (define (o a fn-i)
        (set! x (+ x a))
        (set! y (+ y (fn-i))))
      (for (i 1 100000)
        (o 1 (lambda () i)))
      [x y])
   [100000 5000050000])

(T '(let ((x 0)
          (y 0))
      (define (o a fn-i)
        (set! x (+ x a))
        (set! y (+ y (fn-i))))
      (for (i 1 100000)
        (let ((j i))
          (o 1 (lambda () j))))
      [x y])
   [100000 5000050000])

; Test basic variable handling:
(T '(begin (define y 30) y) 30)
(T '(begin (define x 12)
           (define y 30)
           (set! y 10)
           y) 10)

; Test data loading:
(T 'a: a:)
(T '[1 2 3] '(1 2 3))
(T '{x: 12} {x: 12})
(T ''{x: 12} {x: 12})
(T '{x: (+ 6 2)} {x: 8})
(T ''(1 2 3) '(1 2 3))
(T ''(eq? 1 2) '(eq? 1 2))

; Test arithmetics:
(T '(+ 1 2 3) 6)
(T '(+ 1.2 2 3) 6.2)
(T '(* 1.2 2 3) 7.2)
(T '(/ 8 2 2) 2)
(T '(/ 5 2) 2)
(T '(- 10.5 1.3 2.2) 7)
(T '(< 1 2) #true)
(T '(> 1 2) #false)
(T '(<= 1 2) #true)
(T '(<= 1 2) #true)
(T '(<= 2 2) #true)
(T '(<= 2.1 2) #false)
(T '(>= 2.1 2) #true)

(T '(abs 10)        10)
(T '(abs -10)       10)
(T '(abs 10.123)    10.123)
(T '(abs -10.123)   10.123)

; Test string to number conversion:
(T '(string->number "10")     10)
(T '(string->number "-10")    -10)
(T '(string->number "-10.0")  -10.0)
(T '(string->number "2r11")   3)
(T '(string->number "-2r11")  -3)
(T '(string->number "3r11")   4)
(T '(string->number "4r11")   5)
(T '(string->number "5r11")   6)
(T '(string->number "6r11")   7)
(T '(string->number "7r11")   8)
(T '(string->number "8r11")   9)
(T '(string->number "9r11")   10)
(T '(string->number "10r11")  11)
(T '(string->number "11r11")  12)
(T '(string->number "12r11")  13)
(T '(string->number "13r11")  14)
(T '(string->number "14r11")  15)
(T '(string->number "15r11")  16)
(T '(string->number "16r11")  17)
(T '(string->number "17r11")  18)
(T '(string->number "18r11")  19)
(T '(string->number "19r11")  20)
(T '(string->number "20r11")  21)
(T '(string->number "21r11")  22)
(T '(string->number "22r11")  23)
(T '(string->number "23r11")  24)
(T '(string->number "24r11")  25)
(T '(string->number "25r11")  26)
(T '(string->number "26r11")  27)
(T '(string->number "27r11")  28)
(T '(string->number "28r11")  29)
(T '(string->number "29r11")  30)
(T '(string->number "30r11")  31)
(T '(string->number "31r11")  32)
(T '(string->number "32r11")  33)
(T '(string->number "33r11")  34)
(T '(string->number "34r11")  35)
(T '(string->number "35r11")  36)
(T '(string->number "36r11")  37)
(T '(string->number "36rA")   10)
(T '(string->number "36rZ")   35)
(T '(string->number "36rBUKALISP")
   928536398953)

; Test number->string
(T '(number->string (string->number "36rBUKALISP" 36) 36) "36RBUKALISP")
(T '(number->string (string->number "36rBUKALISP" 31) 36) "Q043R35317")
(T '(number->string (string->number "36rZZZZZZZZ") 36) "ZZZZZZZZ")
(T '(number->string (string->number "-36rZZZZZZZZ") 36) "-ZZZZZZZZ")
(T '(number->string 15 16)  "F")
(T '(number->string 16 16)  "10")
(T '(number->string 1024 2) "10000000000")
(T '(number->string 32 2)   "100000")

; Test procedures:
(T '(eqv? #t #t) #true)
(T '(eqv? #f #f) #true)
(T '(eqv? #t #f) #false)

(T '(eqv? a: a:) #true)
(T '(eqv? a: b:) #false)

(T '(eqv? 'a 'a) #true)
(T '(eqv? 'a 'b) #false)

(T '(eqv? 2 (/ 4 2)) #true)
(T '(eqv? 2 (/ 4.0 2.0)) #false)
(T '(eqv? 2.0 (/ 4.0 2.0)) #true)

(T '(eqv? [] []) #false)
(T '(eqv? {} {}) #false)
(T '(eqv? { x: 11 } { x: 10 }) #false)
(T '(eqv? 2 (/ 5 2)) #true)
(T '(eqv? 2 (/ 5.0 2)) #false)
(T '(eqv? #f 0) #false)
(T '(eqv? #f []) #false)
(T '(eqv? 2.0 2) #false)

(T '(eqv? + (let ((y +)) y)) #true)
(T '(eqv? + (let ((o +)) (let ((y +)) y o))) #true)
(T '(let ((m { x: 11 }) (l #f)) (set! l m) (eqv? m l)) #true)

; eqv? as procedure:
(T '(let ((e eqv?)) (e { x: 11 } { x: 10 })) #false)
(T '(let ((e eqv?)) (e 2 (/ 5 2))) #true)

; Test not
(T '(not #t) #false)
(T '(not 1) #false)
(T '(not '()) #false)
(T '(not #f) #true)

; Test equal?
(T '(equal? 'a 'a)                #t)
(T '(equal? '(a) '(a))            #t)
(T '(equal? '(a (b) c)
            '(a (b) c))           #t)
(T '(equal? '(a (c) c)
            '(a (b) c))           #f)
(T '(equal? '(a c c)
            '(a (b) c))           #f)
(T '(equal? "abc" "abc")      #t)
(T '(equal? 2 2)                  #t)
(T '(equal? {a: [1 2 3] b: 3}
            {b: 3 a: [1 2 3]})    #t)
(T '(equal? {b: [1 2 3]}
            {b: 3 a: [1 2 3]})    #f)

; Testing predicates
(T '(symbol? 'a) #true)
(T '(symbol? a:) #false)
(T '(symbol? 1) #false)

(T '(keyword? a:) #true)
(T '(keyword? 'a) #false)
(T '(keyword? 1) #false)

(T '(nil? 1) #false)
(T '(nil? 0) #false)
(T '(nil? []) #false)
(T '(nil? nil) #true)

(T '(exact? nil) #false)
(T '(exact? 123) #true)
(T '(exact? 1.0) #false)

(T '(inexact? nil) #false)
(T '(inexact? 123) #false)
(T '(inexact? 1.0) #true)

(T '(number? 'x)            #false)
(T '(number? x:)            #false)
(T '(number? [1 2 3])       #false)
(T '(number? { a: 1 b: 2 }) #false)
(T '(number? [])            #false)
(T '(number? {})            #false)
(T '(number? #true)         #false)
(T '(number? #false)        #false)
(T '(number? nil)           #false)
(T '(number? 1)             #true)
(T '(number? "abc")         #false)

(T '(string? 1) #false)
(T '(string? a:) #false)
(T '(string? 'a) #false)
(T '(string? "foo") #true)
(T '(boolean? "foo") #false)
(T '(boolean? #t) #true)
(T '(boolean? #f) #true)
(T '(boolean? nil) #false)

(T '(list? nil) #false)
(T '(list? []) #true)
(T '(list? '()) #true)
(T '(list? string?) #false)
(T '(list? {}) #false)

(T '(map? {}) #true)
(T '(map? '()) #false)
(T '(map? []) #false)
(T '(map? nil) #false)

(T '(procedure? string?) #true)
(T '(procedure? (lambda (x) x)) #true)
;(T '(procedure? if) #false)
(T '(procedure? '()) #false)

(T '(symbol? 'x)             '#true)
(T '(symbol? x:)             '#false)
(T '(symbol? [1 2 3])        '#false)
(T '(symbol? { a: 1 b: 2 })  '#false)
(T '(symbol? [])             '#false)
(T '(symbol? {})             '#false)
(T '(symbol? #true)          '#false)
(T '(symbol? #false)         '#false)
(T '(symbol? nil)            '#false)
(T '(symbol? 1)              '#false)
(T '(symbol? "abc")          '#false)

(T '(keyword? 'x)            '#false)
(T '(keyword? x:)            '#true)
(T '(keyword? [1 2 3])       '#false)
(T '(keyword? { a: 1 b: 2 }) '#false)
(T '(keyword? {})            '#false)
(T '(keyword? [])            '#false)
(T '(keyword? #true)         '#false)
(T '(keyword? #false)        '#false)
(T '(keyword? nil)           '#false)
(T '(keyword? 1)             '#false)
(T '(keyword? "abc")         '#false)

(T '(list? 'x)               '#false)
(T '(list? x:)               '#false)
(T '(list? [1 2 3])          '#true)
(T '(list? { a: 1 b: 2 })    '#false)
(T '(list? [])               '#true)
(T '(list? {})               '#false)
(T '(list? #true)            '#false)
(T '(list? #false)           '#false)
(T '(list? nil)              '#false)
(T '(list? 1)                '#false)
(T '(list? "abc")            '#false)

(T '(map? 'x)                '#false)
(T '(map? x:)                '#false)
(T '(map? [1 2 3])           '#false)
(T '(map? { a: 1 b: 2 })     '#true)
(T '(map? [])                '#false)
(T '(map? {})                '#true)
(T '(map? #true)             '#false)
(T '(map? #false)            '#false)
(T '(map? nil)               '#false)
(T '(map? 1)                 '#false)
(T '(map? "abc")             '#false)

(T '(string? 'x)             '#false)
(T '(string? x:)             '#false)
(T '(string? [1 2 3])        '#false)
(T '(string? { a: 1 b: 2 })  '#false)
(T '(string? [])             '#false)
(T '(string? {})             '#false)
(T '(string? #true)          '#false)
(T '(string? #false)         '#false)
(T '(string? nil)            '#false)
(T '(string? 1)              '#false)
(T '(string? "abc")          '#true)

(T '(boolean? 'x)            '#false)
(T '(boolean? x:)            '#false)
(T '(boolean? [1 2 3])       '#false)
(T '(boolean? { a: 1 b: 2 }) '#false)
(T '(boolean? [])            '#false)
(T '(boolean? {})            '#false)
(T '(boolean? #true)         '#true)
(T '(boolean? #false)        '#true)
(T '(boolean? nil)           '#false)
(T '(boolean? 1)             '#false)
(T '(boolean? "abc")         '#false)

(T '(nil? 'x)                '#false)
(T '(nil? x:)                '#false)
(T '(nil? [1 2 3])           '#false)
(T '(nil? { a: 1 b: 2 })     '#false)
(T '(nil? [])                '#false)
(T '(nil? {})                '#false)
(T '(nil? #true)             '#false)
(T '(nil? #false)            '#false)
(T '(nil? nil)               '#true)
(T '(nil? 1)                 '#false)
(T '(nil? "abc")             '#false)

; Test (type ...):
(T '(let ((m { 'nil 1234 }))
      (@(type nil) m))
   nil)

(T '(let ((m { (type nil) 1234 }))
      (@(type nil) m))
   1234)

(T '(type []) 'list)
(T '(type [1 2 3]) 'list)
(T '(type '()) 'list)
(T '(type '(1 2 3)) 'list)
(T '(type {}) 'map)
(T '(type map?) 'procedure)
(T '(type (lambda () nil)) 'procedure)
(T '(type 1) 'exact)
(T '(type 1.0) 'inexact)
(T '(type nil) 'nil)
(T '(type #t) 'boolean)
(T '(type #f) 'boolean)
(T '(type 'f) 'symbol)
(T '(type f:) 'keyword)
(T '(type "f") 'string)

; Test 'length' primitive
(T '(length [1 2 3]) 3)
(T '(length []) 0)
(T '(length '()) 0)
(T '(length {}) 0)
(T '(length {x: 12}) 1)
(T '(length {y: 324 x: 12}) 2)
(T '(length (let ((l [])) (@!9 l l))) 10)

(T '(length (list 1 2 3)) 3)
(T '(length (list)) 0)
(T '(if (>  (length (list 1 2 3)) 3) "yes" "no") "no")
(T '(if (>= (length (list 1 2 3)) 3) "yes" "no") "yes")
(T '(begin (let ((c length)) (c [1 2 3 (define x 20)]))) 4)
(T '(begin (length [1 2 3 (define x 20)]) x) 20)
(T '(begin [1 2 3 (define x 20)] x) 20)

(T '(length "abcdef")       6)
(T '(length abcd:)          4)
(T '(length 'abc)           3)
(T '(length [1 2 3])        3)
(T '(length {a: 10 b: 20})  2)

; Test other primitives:
(T '(first '(a b c)) 'a)
(T '(first '()) 'nil)
(T '(first [3]) '3)
(T '(last [1 2 3]) '3)
(T '(last [3]) '3)
(T '(last []) 'nil)
(T '(take [x: y: 12 3 4] 2) '(x: y:))
(T '(take [1] 2) '(1))
(T '(take [1 2] 2) '(1 2))
(T '(take [] 2) '())
(T '(drop [1 2 3] 2) '(3))
(T '(drop [1 2 3] 4) '())
(T '(drop [1 2 3] 3) '())
(T '(drop [] 3) '())
(T '(drop [1 2 3] 0) '(1 2 3))
(T '(drop [1 2 3] 1) '(2 3))
(T '(append [1 2 3] 1 a: { x: 12 } [5 5 5]) '(1 2 3 1 a: x: 12 5 5 5))
(T '(append [1 2 3]) '(1 2 3))
(T '(let ((l [1 2 3 4]))
      (pop! l)
      l)
   [1 2 3])
(T '(let ((l [1 2 3 4]))
      (push! l 5)
      l)
   [1 2 3 4 5])
(T '(let ((l [1 2 3 4]))
      (shift! l)
      l)
   [2 3 4])
(T '(let ((l [1 2 3 4]))
      (unshift! l 0)
      l)
   [0 1 2 3 4])

; Test system primitives:
(T '(sys-slurp-file "foo.txt") "xxx\n")

; Test let TODO: Moar!
(T '(let ((x 10)) x) 10)

; Test some assignment stuff:
(T '(begin
      (define x 0)
      (set! x (+ x 1 2 3 4 5))) 15)
(T '(begin
      (define x 0)
      (set! x (not x)))
   #f)

; Testing big lambda applications:
(T '((lambda (x)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)) 9)
   9)

(T '((lambda (x)   (+ x 1)) 1.5) 2.5)
(T '((lambda (x y) (+ (* x y) 1)) 1.5 4) 7.0)
(T '((lambda (x y _ _ _) (+ (* x y) 1)) 1.5 4 e: r: g:) 7.0)
(T '((lambda (x)
       ((lambda (y) (+ x y))
        10))
     5)
   15)
(T '((lambda (x)
       ((lambda (y) (+ 1 0 3 30 30 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10))
     5) 16)

(T '(let ((x [])
          (c 10))
      (set! c (lambda (o) (push! x o)))
      (c 1)
      (c 2)
      x)
   [1 2])

; Test recursive calling:
(T '(let ((x [])
          (c 11))
      (set! c
        (lambda (o)
          (push! x o)
          (when (eqv? o 0)
            (return 11))
          (c (- o 1))))
      (c 2)
      x)
   [2 1 0])

; Test define
(T '(begin (define x 10) x)     10)
(T '(begin (define (x) 10) (x)) 10)
(T '(begin
      (define (x b c)
        (+ (* b c) 10))
      (x 2.5 10))
   35)
(T '(begin (define x 10) (define x 20) x) 20)
(T '(begin (define x 10) (define y 20) (define x 21) [x y]) '(21 20))
(T '(begin (define x 10) (define y 20) (define x y) x) 20)
(T '(begin (define if 10) if) 10)


; Test varargs
(T '((lambda (. x) x))              [])
(T '((lambda (. x) x) 1 2 3)        [1 2 3])
(T '((lambda (a . x) [a x]) 1 2 3)  [1 [2 3]])
(T '((lambda (a . x) [a x]) 1)      [1 []])
(T '((lambda (a . x) [a x]) nil)    [nil []])
(T '(begin
      (define (x a . v) [a v])
      (x 1 2 3))
   [1 [2 3]])

(T '(begin
      (define (x a . v)
        (define z v)
        [a z])
      (x 1 2 3))
   [1 [2 3]])

; Test using a known environemt which is mutatable:
(let ((my-env {}))
  (T-env '(begin (define x 13.3)) 13.3 my-env)
  (T-env '(begin x)               13.3 my-env)
  (T-env '(define y x)            13.3 my-env)
  (T-env '(+ x y)                 26.6 my-env))

; test externally given environment executed inside VM:
(let ((my-env {}))
  (set-root-env-var my-env 'foo 123)
  (T-env '(begin foo) 123 my-env)
  #;(displayln (pp-str my-env))
  (T-env '(begin
            (define k 10)
            ((lambda () foo)))
         123
         my-env))

; test recursive calling into VM:
(let ((my-env {})
      (func (bukalisp-compile
              "tests_x1"
              ['(displayln foo-out: (+ 10 20))]
              my-env
              #t)))
  (set-root-env-var my-env 'xxx func)
  (T-env '(begin
            (define k 10)
            ((lambda ()
               (bkl-run-vm-prog xxx {})))
            (+ 12.345 k))
         22.345
         my-env))

; Calling the VM directly using a closure
(T '(let ((closure (lambda (a b) (+ a b))))
      (bkl-run-vm closure nil [1 2]))
   3)

; Test conditionals:
(T '(when   #t 10) 10)
(T '(when   #f 10) nil)
(T '(unless #t 10) nil)
(T '(unless #f 10) 10)
(T '(begin
      (define x 10)
      (when (> 0 -1)
        (let ((y 22))
          (set! x (* 1.23 x y))))
      x)
   270.6)
(T '(begin
      (define x 10)
      (when (> 0 1)
        (let ((y 22))
          (set! x (* 1.23 x y))))
      x)
   10)

(T '(if #t 10 20) 10)
(T '(if #t 10)    10)
(T '(if #f 10 20) 20)
(T '(if #f 10)    nil)

(T '(begin
      (define x 10)
      (if (> 0 -1)
        (let ((y 22))
          (set! x (* 1.27 x y)))
        (let ((y 22))
          (set! x (* 1.23 x y))))
      x)
   279.4)

(T '(begin
      (define x 10)
      (if (> 0 1)
        (let ((y 22))
          (set! x (* 1.27 x y)))
        (let ((y 22))
          (set! x (* 1.23 x y))))
      x)
   270.6)

(T '(let ((aid  (atom-id (type nil)))
          (aid2 (atom-id (type nil)))
          (aid3 (atom-id (type nil))))
      [(eqv? aid aid2) (eqv? aid aid3)])
   '(#t #t))


(T '(begin (define x 0)
           (define (o a)
             (set! x (+ x a)))
           (for (i 1 1000000)
             (o 1)))
   1000000)

(T '(begin (define x 0)
;           (define (o a)
;             (set! x (+ x a)))
           (for (i 1 10000000)
             (set! x (+ x 1))))
   10000000)

(T '(begin (define x 0)
           (for (i 0 -100 -1)
             (set! x (+ x i)))
           x)
   -5050)

(T '(begin
      (define x 1)
      (for (i 1 0) (set! x 20) i)
      x)
   1)

(T '(begin
      (define x 1)
      (for (i 1 1) (set! x (+ i 20)) i)
      x)
   21)

(T '(begin
      (define x 1)
      (for (i 1 2) (set! x (+ i 20)) i)
      x)
   22)

; Test binary ops that are (sometimes) optimized by the compiler
; to be statically compiled down to VM OPs:
(T '(+ 1 2 3) 6)
(T '(let ((x +)) (x 1 2 3)) 6)

(T '(+ 2 3) 5)
(T '(let ((x +)) (x 2 3)) 5)

(T '(- 10 2 3) 5)
(T '(let ((x -)) (x 10 2 3)) 5)

(T '(- 10 2) 8)
(T '(let ((x -)) (x 10 2)) 8)

(T '(- 10) -10)
(T '(let ((x -)) (x 10)) -10)

(T '(= 10 10) #t)
(T '(= 10 9) #f)
(T '(let ((x =)) (x 10 10)) #t)
(T '(let ((x =)) (x 10 9)) #f)

(T '(= 10 10 10) #t)
(T '(= 10 10 9) #f)
(T '(let ((x =)) (x 10 10 10)) #t)
(T '(let ((x =)) (x 10 10 9)) #f)


(T '(< 10 11) #t)
(T '(< 10 10) #f)
(T '(< 10 11 12) #t)
(T '(< 10 11 11) #f)
(T '(let ((x <)) (x 10 11 12)) #t)
(T '(let ((x <)) (x 10 11 11)) #f)

(T '(> 11 10) #t)
(T '(> 11 11) #f)
(T '(> 12 11 10) #t)
(T '(> 12 11 11) #f)
(T '(let ((x >)) (x 12 11 10)) #t)
(T '(let ((x >)) (x 12 11 11)) #f)

(T '(>= 11 10) #t)
(T '(>= 11 12) #f)
(T '(>= 12 11 10) #t)
(T '(>= 12 11 12) #f)
(T '(let ((x >=)) (x 12 11 10)) #t)
(T '(let ((x >=)) (x 12 11 12)) #f)

(T '(<= 10 11) #t)
(T '(<= 11 11) #t)
(T '(<= 10 9) #f)
(T '(<= 11 11 12) #t)
(T '(<= 11 11 9) #f)
(T '(let ((x <=)) (x 11 11 12)) #t)
(T '(let ((x <=)) (x 11 11 9)) #f)

; Test accessor operations like @, $, $! and @!
(T ''@ '@)
(T ''@! '@!)

(T '(@0 [22.2 22.4 45]) 22.2)
(T '(let ((at @)) (at 0 [22.2 22.4 45])) 22.2)
(T '(let ((x [])) (@!2 x 10) x) [nil nil 10])
(T '(let ((x [])
          (at-set! @!))
      (at-set! 2 x 10) x)
   [nil nil 10])

(T '(@x: {x: 22.2}) 22.2)
(T '(let ((at @)) (at x: {x: 22.2})) 22.2)
(T '(let ((x {})) (@!x: x 10) x) {x: 10})
(T '(let ((x {})
          (at-set! @!))
      (at-set! x: x 10) x)
   {x: 10})

(T '(let ((x 2) (v [1 2 3])) (@x v)) 3)

(T '(@'x {'x 10}) 10)
(T '(let ((m {'x 10})) (@!'x m 12) m) {'x 12})

; Test include
(T '(begin
      (include "../tests/compiler/test_compiler_incl.bkl")
      test-include-ok)
   1)

; Test meta-infos:
(T '(let ((v []))
      (bkl-set-meta v 2 42)
      (bkl-get-meta v))
   '(nil nil 42))

; Test macros:
(T '(begin
      (define x 10)
      (define m nil)
      (let ()
       (define-macro (x a b)
         ['quote [a b a b]])
       (set! m (x 9 11)))
      [m x])
   [[9 11 9 11] 10])

; Test $define!
(T '(let ((o {x: 0}))
      ($define! o (foo) 9)
      ((@'foo o)))
   9)
(T '(let ((o {x: 0}))
      ($define! o (foo) 9)
      [((@'foo o))])
   [9])
(T '(let ((o {x: 0}))
      ($define! o (foo a b c)
        9
        (@!x: o (+ 1 (x: o)))
        (* a (+ (x: o)
                b
                (* 2 c))))
      [((@'foo o) 1 2 3)
       ((@'foo o) 4 5 6)
       ((@'foo o) 8 8 8)
       ((@'foo o) 9 9 9)])
   [9 76 216 279])

; Test return:
(T '(begin (define x 11) (set! x 32) (return x)) 32)
(T '(begin (define x 11)
           (set! x (return x))
           (return x)) 11)
(T '(begin (define g 10)
           ((lambda ()
              (set! g 33)
              (return nil)
              (set! g 45)))
           g)
   33)
(T '(begin (define g 10)
           ((lambda ()
              (set! g 33)
              (return g)
              (set! g 45))))
   33)
(T '(return 32) 32)
(T '{a: 10 x: (return 20)} 20)

; Test predicates:
(T '(list? (list))                  #true)
(T '(let ((x list?)) (x (list)))    #true)
(T '(list? { a: 1 })                #false)
(T '(let ((x list?)) (x { a: 1 }))  #false)

(T '(empty? (list))                 #true)
(T '(empty? (list 1))               #false)
(T '(empty? {})                     #true)
(T '(empty? {a: 1})                 #false)
(T '(let ((x empty?)) (x (list)))   #true)
(T '(let ((x empty?)) (x (list 1))) #false)
(T '(let ((x empty?)) (x {}))       #true)
(T '(let ((x empty?)) (x {a: 1}))   #false)

; Test (size)
(T '(size nil)      0)
(T '(size [])       0)
(T '(size {})       0)
(T '(size {a: 1})   2)
(T '(size [1])      1)
(T '(size [[]])     1)
(T '(size fooo:)    4)
(T '(size "fooo")   4)
(T '(size 'fooo)    4)
(T '(size [1 2 3 4 [5 6 7 8] 9]) 10)
(T '(size [1 2 3 4 {a: 5 b: 6 c: 7 d: 8} 9]) 14)

; Test return anywhere:
(T '(let ((j (return (+ 9 10)))) nil) 19) ; XXX: Should let be allowed to be empty?

(T '{ b: 20 a: (return 9) x: 22 }
   9)
(T '(list? (return 10)) 10)
(T '(empty? (return 11)) 11)
;(T '(define-global ff (return 12)) 12)
(T '(define ff2 (return 12)) 12)
(T '(begin
      (define ff2 12)
      (set! ff2 (return 13)))
   13)
(T '((return 14) 22) 14)
(T '(begin
      (define x 2)
      ((lambda () 2)
       ((lambda ()
          (set! x 16)))
       (return x)))
   16)
(T '(begin
      (define x 1)
      (+ ((lambda ()
            (set! x 15)))
         (return x)))
   15)
(T '(begin
       (define x 1)
       (define y 2)
       (+
         ((lambda () (set! y 16)))
         (+ ((lambda () (set! x 15)))
            (return (+ x y)))))
   31)
(T '(begin
      (let ((a 10) (b 20)) b)
      (let ((c 30))
        (let ((k 32)
              (j (return (+ k 10)))) nil))
      44)
   42)
(T '(let ((x 11))
      (let ((if (= (set! x 43) (return x)))) 12)
      x)
   43)
(T '(if #t (return 44)) 44)
(T '(if #f 10 (return 45)) 45)
;(T '(begin
;      (define X 10)
;      (. (set! X 47) (return X)))
;   47)

; Test quote
(T ''(+ 1 2) '(+ 1 2))
(T ''((3 4)) '((3 4)))
(T ''(+ 1 (+ 2 3)) '(+ 1 (+ 2 3)))
(T '   '     ( +     1 (+  2 3 )      ) '(+ 1 (+ 2 3)))
(T ''(* 1 2) '(* 1 2))
(T ''(** 1 2) '(** 1 2))
(T ''(1 2 3) '(1 2 3))
(T '''1 '(quote 1))
(T '''(1 2 3) '(quote (1 2 3)))
(T '(quote 7) '7)
(T ''7 '7)
(T '(quote (1 2 3)) '(1 2 3))
(T ''(1 2 3) '(1 2 3))
(T '(quote (1 2 (3 4))) '(1 2 (3 4)))
(T ''(1 2 (3 4)) '(1 2 (3 4)))
(T '(quote (10)) '(10))

; Test apply
(T '(apply + 1 2 3 []) '6)
(T '(apply + 1 2 3 (list)) '6)
(T '(apply + 1 (list 2 3)) '6)
(T '(apply - 0 (list 1)) '-1)
(T '(apply - (list 0 1)) '-1)
(T '(apply str-join "," (list X: Y:)) '"X,Y")

; Test bkl-doc documentation
(T '(begin
      (bkl-set-doc! xxx-test-bkl: "foobar-xxx-yyy")
      (?doc ?foobar-x:))
   ["foobar-xxx-yyy"]);
(T '(begin
      (bkl-set-doc! xxx-test-bkl: "foobar-xxx-yyy")
      (?doc xxx-test:))
   ["foobar-xxx-yyy"]);
(T '(begin
      (bkl-set-doc! xxx-test-bkl: "foobar-xxx-yyy")
      (?doc xxx-yyy:))
   []);
(T '(begin
      (bkl-set-doc! xxx-test-bkl: "foobar-xxx-yyy")
      (?doc *-yyy:))
   ["foobar-xxx-yyy"]);

; Test while
(T '(let ((i 0) (j 1.0))
      (while (< i 3)
             (set! j (* j 2))
             (set! i (+ i 1)))
      j)
   8)

(T '(begin
      (define x 100000)
      (define k 0)
      (let ((inco (lambda (a) (set! x (+ x a)))))
        (while (> x k)
               (inco -1))))
   0)

; Test do-each
(T '(let ((o []))
      (do-each (x [1 2 3])
        (push! o x))
      o)
   [1 2 3])

(T '(let ((o []))
      (do-each (x [])
        (push! o x))
      o)
   [])

(T '(let ((sum 0))
      (do-each (v {a: 1 b: 2 c: 3 e: 5 f: 11})
        (set! sum (+ sum v)))
      sum)
   22)

(T '(let ((o []))
      (do-each (k v [5 6 7])
        (push! o k)
        (push! o v))
      o)
   [0 5 1 6 2 7])

(T '(let ((o []))
      (do-each (k v {a: 12})
        (push! o k)
        (push! o v))
      o)
   [a: 12])

(T '(let ((o []))
      (do-each (k v {})
        (push! o k)
        (push! o v))
      o)
   [])

; Test do-each regressions
(T '(let ((x 0))
      (do-each (row [[1] [2] [3] [4]])
        (if #t
            (begin
              (set! x (+ x (@0 row)))
              (str (@0 row)))))
      x)
   10)

(T '(let ((x 0))
      (do-each (row [[1] [2] [3] [4]])
        (case 0
          (else
            (set! x (+ x (@0 row)))
            (str (@0 row)))))
      x)
   10)

(T '(let ((x 0))
      (do-each (row [[1] [2] [3] [4]])
        (case (@0 row)
          (else
            (set! x (+ x (@0 row)))
            (str X: (@0 row))
            nil)))
      x)
   10)

; Testing some shallow copy operations and assignments
(T '(let ((v [1 2 3])
          (v_ (list-copy v)))
      [(eqv? v v) (eqv? v v_) v_])
   [#t #f [1 2 3]])

(T '(let ((m {a: 10})
          (m_ (map-copy m)))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f {a: 10}])

(T '(let ((m {a: 10})
          (m_ (assign m [a: 20])))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f {a: 20}])

(T '(let ((m {a: 10})
          (m_ (assign m {a: 20})))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f {a: 20}])

(T '(let ((m [1 2 3 4])
          (m_ (assign m {0 10 2 30})))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f [10 2 30 4]])

(T '(let ((m [1 2 3 4])
          (m_ (assign m [0 10 2 30])))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f [10 2 30 4]])

; Test eval
(T '(eval 1)                    1)
(T '(eval '(+ 1 2))             3)
(T '(eval '(eval '(+ 1 2)))     3)
(T '(eval '(eval '(+ 1 2)))     3)
(T '(let ((env (interaction-environment)))
      (eval '(define x 12) env)
      (eval 'x env))
   12)
(T '(let ((env (interaction-environment)))
      (eval '(define x 12) env)
      (eval '(set! x (* x 2)) env)
      (eval 'x env))
   24)

; Test nested eval:
(T '(let ((x {}))
      (eval '1 x)
      (eval '(define M 10) x)
      (eval '(+ 1
                (eval '(+ 1
                          (eval M)))) x))
   12)

; Test eval as procedure:
(T '(let ((e eval))
      (e '(+ 1 2 3)))
   6)

; Testing coroutine predicates:
(T '(let ((c (lambda () nil)))
      (coroutine? c))
   #f)

(T '(let ((c (lambda :coroutine () nil)))
      (coroutine? c))
   #t)

(T '(let ((c (lambda :coroutine () (yield 10) nil)))
      (c)
      (coroutine? c))
   #t)

(T '(let ((c (lambda () nil)))
      (coroutine-yielded? c))
   #f)

(T '(let ((c (lambda :coroutine () nil)))
      (coroutine-yielded? c))
   #f)

(T '(let ((c (lambda :coroutine () (yield 10) nil)))
      (c)
      (coroutine-yielded? c))
   #t)
(T '(let ((c (lambda :coroutine () (yield 10) nil)))
      (c)
      (c)
      (coroutine-yielded? c))
   #f)

(T '(current-coroutine) nil)

; Testing coroutines:
(T '(let ((x 10)
          (c (lambda :coroutine ()
               (set! x 20)
               (yield 21)
               (set! x 22))))
      [x (c) x (c)])
   [10 21 20 22])

(T '(let ((x 10)
          (c (lambda :coroutine ()
               (for (i 0 2)
                 (yield i))
               FF:)))
      [(c) (c) (c) (c) (c) (c)])
   [0 1 2 FF: 0 1])

(T '(let ((x 10)
          (mo (lambda ()
                (for (i 0 2)
                  (yield i))))
          (c (lambda :coroutine ()
               (mo)
               (mo)
               (yield OO:)
               FF:)))
      [(c) (c) (c) (c) (c) (c)
       (c) (c) (c) (c)])
   [0 1 2 0 1 2 OO: FF: 0 1])

; Check if arity is not checked when calling a yielded coroutine:
(T '(begin
      (define :coroutine (x)
        (yield 10))
      [(x)
       (x 11)])
   [10 11])

; Test define coroutine syntax:
(T '(begin
      (define k 0)
      (define :coroutine (fn x)
        (set! k x)
        (set! k (yield 20))
        30)
      [k
       (fn 10)
       k
       (fn 31)
       k])
   [0 20 10 30 31])

; Recursive coroutine calling of the same :coroutine
; Works, because the coroutine restores the last yield point only once.
; This should not be changed or mixed up with continuations:
;   We never should re-enter the same execution context
;   twice, as the temporary work context registers are not correctly
;   set. For re-callable continuations we need to save them with the stack!
(T '(let ((x [])
          (c nil))
      (set! c
        (lambda :coroutine (o)
          (push! x o)
          (when (eqv? o rec:)
            (push! x (yield XX:))
            (push! x (c foo:))
            (push! x (c foo:))
            (push! x (c foo:)))
          (when (eqv? o foo:)
            (push! x (yield 10))
            (push! x (yield 11))
            (push! x (yield 12)))
          END:))
      (c rec:)
      (c cont:)
      x)
   [rec: cont: foo: 10 foo: 11 foo: 12])

; Multi-level coroutine continuation
(T '(let ((fn (lambda :coroutine ()
                (+ 13
                   ((lambda (x)
                      (set! x (+ 1 x))
                      (yield nil)
                      (set! x (* 2 x))
                      x)
                    11)))))
      (fn)
      (fn))
   37)

; Testing recursing into VM using a coroutine:
(T '(let ((coro (lambda :coroutine ()
                  (yield 10)
                  (yield 20)
                  (yield 30)
                  40)))
      [(bkl-run-vm coro)
       (bkl-run-vm coro)
       (bkl-run-vm coro)
       (bkl-run-vm coro)
       (bkl-run-vm coro)
       (bkl-run-vm coro)
       (bkl-run-vm coro)
       (bkl-run-vm coro)])
   [10 20 30 40 10 20 30 40])

; Accessing the current coroutine from the dynamic environment:
(T '(let ((coro (lambda :coroutine (a)
                  (define cc (current-coroutine))
                  (bkl-set-meta cc 2 a)))
          (l []))
      (bkl-set-meta coro 2 100)
      (push! l (@2 (bkl-get-meta coro)))
      (coro 12)
      (push! l (@2 (bkl-get-meta coro)))
      l)
   [100 12])

; Testing coroutine stack ordering after restore:
(T '(begin
      (define (yld i)
        (yield i))
      (define (fx)
        (yld 1)
        (yld 2))
      (define :coroutine (cx)
        (fx)
        (yld 3))
      [(cx) (cx) (cx)])
   [1 2 3])

(T '(begin
      (define (yld i)
        (yield i))
      (define (fx)
        (yld 10)
        (yld 20)
        (yld 21)
        (yld 22)
        (yld 23))
      (define :coroutine (cx)
        (yld 5)
        (fx)
        (yld 30))
      [(cx) (cx) (cx) (cx) (cx) (cx) (cx) (cx)])
   [5 10 20 21 22 23 30 nil])


; Exception handling
(T '(handle-exceptions x x (raise 10))
   10)

(T '(handle-exceptions x x 10) 10)

(T '(let ((f (lambda (fn)
               (handle-exceptions _ _ (fn)))))
      (f (lambda () 10)))
   10)

(T '(handle-exceptions
      x
      10
      ((lambda () (+ 1 2 (raise 11)))))
   10)

(T '(handle-exceptions
      x
      (+ x 10)
      ((lambda () (+ 1 2 (raise 11)))))
   21)

(T '(handle-exceptions
      x
      ((lambda (y) y) x)
      ((lambda () (+ 1 2 (raise 11)))))
   11)

(T '(handle-exceptions
      x
      ((lambda (y) y) x)
      ((lambda () ((lambda () (+ 1 2 (raise 11)))))))
   11)

; Exception handling in interaction with coroutines:

(T '(handle-exceptions
      x
      ((lambda (y) y) x)
      ((lambda :coroutine () ((lambda () (+ 1 2 (raise 11)))))))
   11)

(T '(let ((x 0)
          (l [])
          (fn (lambda :coroutine ()
                (set! x 10)
                (yield 20)
                (set! x 21)
                (raise 30))))
      (handle-exceptions
        ex
        (begin (push! l x) (push! l ex) l)
        (begin (push! l (fn)) (push! l (fn)))))
   [20 21 30])

(T '(let ((x 0)
          (l [])
          (fn (lambda :coroutine ()
                (set! x 10)
                (handle-exceptions
                  ex2
                  (raise [l x ex2])
                  (yield x)
                  (set! x 21)
                  (raise 30)))))
      (handle-exceptions
        ex
        ex
        (push! l (fn))
        (push! l (fn))))
   [[10] 21 30])

; Test cleanup with exceptions and return and without anything
(T '(let ((x 10))
      (with-cleanup
        (set! x 11)
        (set! x 20))
      x)
   11)

; with setup expression:
(T '(let ((x 10))
      [(with-cleanup
        (set! x 20)
        (set! x (* x 2))
        [(set! x (+ x 1))])
       x])
   [[21] 42])

(T '(let ((x 10)
          (raised-obj nil))
      (handle-exceptions
        EX (set! raised-obj EX)
        (with-cleanup
          (set! x 11)
          (begin
            (set! x 20)
            (raise X:))))
      [x raised-obj])
   [11 X:])

(T '(let ((x 10)
          (ret-val ((lambda ()
                      (with-cleanup
                        (set! x 13)
                        (begin
                          (set! x 21)
                          (return [x X:])))))))
      [x ret-val])
   [13 [21 X:]])


(T '(let ((x 10))
      (with-cleanup
        (set! x (* 2 x))
        (with-cleanup
          (set! x 11)
          (set! x 20)))
      x)
   22)

(T '(let ((x 10))
      (with-cleanup
        (with-cleanup (set! x (* 2 x)) (set! x (+ 1 x)))
        (set! x 20))
      x)
   42)

(T '(let ((x 10))
      ((lambda ()
         (with-cleanup
           (with-cleanup
             (set! x (* 2 x))
             (begin (return F:)
                    (set! x (+ 1 x))))
           (set! x 20))))
      x)
   40)

(T '(let ((x 10)
          (raised-obj nil))
      (handle-exceptions
        EX (set! raised-obj EX)
        ((lambda ()
          (with-cleanup
            (set! x 17)
            (begin
              (set! x 20)
              (raise X:))))))
      [x raised-obj])
   [17 X:])

(T '(let ((x 10)
          (raised-obj nil))
      (handle-exceptions
        EX (set! raised-obj EX)
        ((lambda ()
          (handle-exceptions
            UX
            (raise [UX Y:])
            (with-cleanup
              (set! x 17)
              (begin
                (set! x 20)
                (raise X:)))))))
      [x raised-obj])
   [17 [X: Y:]])

(T '((lambda ()
       (with-cleanup
         (return 20)
         (return 10))))
   20)
(T '(handle-exceptions
      X
      X
      ((lambda ()
         (with-cleanup
           (raise 20)
           (return 10)))))
   20)

(T '(handle-exceptions
      X
      X
      ((lambda ()
         (with-cleanup
           (with-cleanup 22
                         (raise 20))
           (raise 10)))))
   20)

(T '(handle-exceptions
      X
      X
      ((lambda ()
         (with-cleanup
           (handle-exceptions _ _ (with-cleanup 22 (raise 20)))
           (raise 10)))))
   10)

(T '(let ((x 10))
      [((lambda ()
          (with-cleanup
            (set! x (+ x 13))
            ((lambda ()
               (with-cleanup
                 (set! x (+ x 2))
                 ((lambda ()
                    (set! x 20)))))))))
       x])
   [20 35])


(T '(let ((x 10))
      [(handle-exceptions
         _ [_ x]
         ((lambda ()
            (with-cleanup
              (set! x (+ x 13))
              ((lambda ()
                 (with-cleanup
                   (set! x (+ x 2))
                   ((lambda ()
                      (raise L:)
                      (set! x 20))))))))))
       x])
   [[L: 25] 25])

; Test return-from
(T '(block x (return-from x 10)) 10)
(T '(block x (return-from* 'x 10)) 10)
(T '(block x 10) 10)

(T '(let ((x 10))
      [(block foo
              (set! x 20)
              (return-from foo 10)
              (set! x 22))
       x])
   [10 20])

(T '(let ((x 10))
      [(block foo
              (with-cleanup
                (set! x (* 3 x))
                (begin
                  (set! x 20)
                  (return-from foo 10)
                  (set! x 22))))
       x])
   [10 60])

(T '(let ((x 10))
      [(block foo
              (with-cleanup
                (set! x (* 3 x))
                (begin
                  (set! x 20)
                  (return-from foo 10)
                  (set! x 22))))
       x])
   [10 60])

(T '(block x
      (handle-exceptions
        _ _
        (return-from x 10)))
   10)

(T '(let ((f (lambda (fn) (block boo (fn)))))
      [(f (lambda () 10))
       (f (lambda () (return-from boo 20) 10))])
   [10 20])

(T '(let ((f (lambda (fn) (block boo (handle-exceptions _ _ (fn))))))
      [(f (lambda () 10))
       (f (lambda () (return-from boo 20) 10))])
   [10 20])


(T '(let ((x nil)
          (f (lambda (fn)
               (block boo
                 (with-cleanup
                   (set! x (+ 1 x))
                   (handle-exceptions _ _ (with-cleanup (set! x 33) (fn))))))))
      [x
       (f (lambda () 10))
       (f (lambda () (return-from boo 20) 10))
       x])
   [nil 10 20 34])


; Test 'and' and 'or'
(T '(or #f 10) 10)
(T '(let ((x 10) (y 0))
      (or (begin (set! x 20) #f)
          (set! y 20))
      [x y])
   [20 20])
(T '(let ((x 10) (y 0))
      (or (begin (set! x 20))
          (set! y 20))
      [x y])
   [20 0])
(T '(let ((x 10) (y 0) (f 0))
      (or (begin (set! x 20) #f)
          (begin (set! f 20) #f)
          (set! y 20))
      [x f y])
   [20 20 20])
(T '(let ((x 10) (y 0) (f 0))
      (or (begin (set! x 20) #f)
          (set! f 20)
          (set! y 20))
      [x f y])
   [20 20 0])
(T '(let ((x 10) (y 0) (f 0))
      (or (set! x 20)
          (set! f 20)
          (set! y 20))
      [x f y])
   [20 0 0])

(T '(and #t 10) 10)
(T '(and 10 #t) #t)
(T '(and 10 #f #t) #f)
(T '(let ((a 0) (b 0) (c 0))
      (and (set! a 10)
           (begin (set! b 20) #f)
           (set! c 30))
      [a b c])
   [10 20 0])
(T '(let ((a 0) (b 0) (c 0))
      (and (set! a 10)
           (set! b 20)
           (set! c 30))
      [a b c])
   [10 20 30])
(T '(let ((a 0) (b 0) (c 0))
      (and #f
           (set! a 10)
           (set! b 20)
           (set! c 30))
      [a b c])
   [0 0 0])

; Test varargs in combination with upvals:
(T '((lambda ()
       (let ((y 10))
         ((lambda (. x)
            [x y])
          1 2 3))))
   [[1 2 3] 10])

(T '((lambda ()
       (let ((y 10))
         ((lambda (a . x)
            [a x y])
          1 2 3))))
   [1 [2 3] 10])

; Test cond
(T '(cond (else 20)) 20)

(T '(cond ((= 1 1) 10)) 10)
(T '(cond ((= 1 0) 10)) nil)
(T '(cond ((= 1 0) 10) (else 13)) 13)
(T '(cond ((= 1 0) 10)
          ((= 1 1) 14)
          (else 13))
   14)

; Test case
(T '(case 1
      ((1)  10)
      ((a:) 11)
      ((l)  12)
      (else 30))
   10)

(T '(case 'l
      ((1)  10)
      ((a:) 11)
      ((l)  12)
      (else 30))
   12)

(T '(case a:
      ((1)  10)
      ((a:) 11)
      ((l)  12)
      (else 30))
   11)

(T '(case b:
      ((1)  10)
      ((a:) 11)
      ((l)  12)
      (else 30))
   30)

(T '(case a: (else 30))
   30)

(T '(case a: ((b: c: a:) 10))
   10)

(T '(case e: ((b: c: a:) 10))
   nil)

; Test do
(T '(let ((x 0)
          (l []))
      (do ((i 10 (+ i 2))
           (d 1.0 (+ d 0.5)))
          ((> i 20) (push! l x) l)
        (push! l d)
        (set! x (+ x 1))))
   [1 1.5 2.0 2.5 3 3.5 6])

(T '(let ((x 0)
          (l []))
      (do ((i 10 (+ i 2)))
          ((not (< i 20)) l)
        (push! l i)))
   [10 12 14 16 18])

(T '(let ((x 0)
          (l []))
      (do ((i 10 (+ i 2)))
          ((> i 20) l)
        (push! l i)))
   [10 12 14 16 18 20])

(T '(let ((x-i '(1 3 5 7 9)))
      (do ((sum 0   (+ sum (first x)))
           (x   x-i (begin (shift! x) x)))
        ((null? x) sum)))
   25)

(T '(do ((l [])
         (m 1)
         (x 0 (+ x 1)))
      ((>= x 10) l)
      (push! l m))
   [1 1 1 1 1 1 1 1 1 1])

; Test define-library and import
(T '(begin
      (define-library
        (x)
        (export yyy)
        (import (bukalisp base))
        (begin
          (define yyy 10))))
   {'yyy [glob-var: 'yyy 10]})

(T '(begin
      (define-library
        (x)
        (export yyy)
        (import (bukalisp base))
        (begin
          (define yyy 10)))
      (import (x))
      yyy)
   10)

(T '(begin
      (define-library
        (x)
        (export yyy)
        (import (bukalisp base))
        (begin
          (define-macro (yyy)
                        11)))
      (import (x))
      (yyy))
   11)

(T '(begin
      (define-library
        (x)
        (export yyy)
        (import (bukalisp base))
        (begin
          (define-macro (yyy a)
                        ['+ a 11])))
      (import (x))
      (yyy 10))
   21)

(T '(begin
      (define-library
        (x)
        (export plus)
        (import (bukalisp base))
        (begin
          (define plus +)))
      (import (x))
      (plus 12 10))
   22)

(T '(begin
      (import (tests-support import-test))
      impt)
   135)

; Test std lib
(define std-env {})
(T-env '(begin (import (bukalisp std)) 1) 1 std-env)

; Test map
(T-env '(begin
          (map (lambda (i) (* i 2))
               [1 2 3 4]))
       [2 4 6 8]
       std-env)

(T-env '(begin
          (map (lambda (i j) [j (* i 2)])
               [1 2 3 4]
               [a: b: :c]))
       [[a: 2] [b: 4] [c: 6] [nil 8]]
       std-env)

(T-env '(begin
          (map (lambda (j i) [j (* i 2)])
               [a: b: :c]
               [1 2 3 4]))
       [[a: 2] [b: 4] [c: 6]]
       std-env)

