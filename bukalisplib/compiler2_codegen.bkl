;----------------------------------------------------------------------------

(include compiler2)
(include code-pad)

;----------------------------------------------------------------------------

(define REG-ROW-FRAME 0)
(define REG-ROW-DATA  1)
(define REG-ROW-PRIM  2)
(define REG-ROW-UPV   3)
(define REG-ROW-ROOT  4)

;----------------------------------------------------------------------------

(define eq-adr?
  (lambda (a b)
    (and (eqv? (@0 a) (@0 b))
         (eqv? (@1 a) (@1 b)))))
;----------------------------------------------------------------------------

(define tmp-pos-or-parent-adr
  (lambda (ctx)
    (if (@parent-ctx: ctx)
      (@parent-ctx: ctx)
      (.new-tmp-pos (F: ctx)))))
;----------------------------------------------------------------------------

(define make-s2-frame
  (lambda (gtx)
    (let ((self {pad: []
                 pos: [0 []]}))
      ($define! self (get-debug-info)
        (last (meta-stack: gtx)))
      ($define! self (store-static-data data)
        (push! (pad: self) data)
        [(- (length (pad: self)) 1) REG-ROW-DATA])
      ($define! self (to-vm-prog code-pad)
        (make-vm-prog [(pad:  self)
                       (.to-vm-prog-code       code-pad)
                       (.to-vm-prog-debug-info code-pad)]))
      ($define! self (new-tmp-pos)
        (let ((env-pos           (pos: self))
              (free-tmp-pos-list (@1 env-pos)))
          (if (> (length free-tmp-pos-list) 0)
            [(pop! free-tmp-pos-list) REG-ROW-FRAME tmp:]
            (let ((new-pos (@0 env-pos)))
              (@!0 env-pos (+ new-pos 1))
              [new-pos REG-ROW-FRAME tmp:]))))
      ($define! self (new-pos)
        (let ((env-pos (pos: self))
              (new-pos (@0 env-pos)))
          (@!0 env-pos (+ 1 new-pos))
          [new-pos REG-ROW-FRAME]))
      ($define! self (recycle-pos-list pos-list)
        (do-each (pos pos-list)
          (.recycle-pos self pos)))
      ($define! self (recycle-pos pos)
        (when (eqv? (@2 pos) tmp:)
          (@!2 pos nil) ; mark it as non-tmp, as we already put it on the free-list
          (push! (@1 (pos: self)) (@0 pos)))
        pos)
      self)))
;----------------------------------------------------------------------------

(define generate-binary-op
  (lambda (node-sym op-gen-sym)
    [node-sym
      (lambda (ctx arg T gtx)
        (let ((out-adr (tmp-pos-or-parent-adr ctx))
              (a-adr  (T ctx (@0 arg)))
              (b-adr  (T ctx (@1 arg))))
          (.(begin op-gen-sym) (P: ctx) out-adr a-adr b-adr)
          (.recycle-pos (F: ctx) a-adr)
          (.recycle-pos (F: ctx) b-adr)
          out-adr))]))
;----------------------------------------------------------------------------

;(define optimize-out-adr!
;  (lambda (ctx out-adr in-adr)
;    (if (and
;          (eqv? (@1 out-adr) REG-ROW-FRAME)
;          (eqv? (@1 in-adr)  REG-ROW-FRAME))
;      (if (eqv? (@2 in-adr) tmp:)
;        (begin
;          (.recycle-pos (F: ctx) out-adr)
;          (@!0 out-adr (@0 in-adr))
;          (@!1 out-adr (@1 in-adr))
;          (@!2 out-adr (@2 in-adr))
;          in-adr)
;        (begin
;          (.recycle-pos (F: ctx) in-adr)
;          out-adr))
;      out-adr)))
;----------------------------------------------------------------------------

(define primitive-map (bkl-primitive-map))

(define stage2-transformer
  (lambda (stage-2-data ctx gtx)
    (find-transform-match
      [['#1#data
        (lambda (ctx arg T gtx)
          (.store-static-data (F: ctx) (first arg)))]
       ['#1#prim
        (lambda (ctx arg T gtx)
          (let ((prim-idx (@(first arg) primitive-map)))
            (unless prim-idx
              (error "Bad primitive in stage 2 compilation" arg))
            [prim-idx REG-ROW-PRIM]))]
       ['#1#begin
        (lambda (ctx arg T gtx)
          (define last-adr nil)
          (do-each (form arg)
            (when last-adr
              (.recycle-pos (F: ctx) last-adr))
            (let ((adr (T ctx form)))
              (set! last-adr adr))
            last-adr))]
       ['#1#var
        (lambda (ctx arg T gtx)
          (let ((adr (@(@0 arg) (env: ctx))))
            (unless adr
              (error "Fatal error in stage 2, variable not found!" arg))
            adr))]
       ['#1#glob-var
        (lambda (ctx arg T gtx)
          (let ((root-var  (@(@0 arg) (root-env: gtx))))
            (unless root-var
              (let ((new-root-adr (@1 arg)))
                (set! root-var [new-root-adr REG-ROW-ROOT])
                (@!(@0 arg) (root-env: gtx) root-var)))
            root-var))]
       ['#1#set!
        (lambda (ctx arg T gtx)
          (let ((var-adr (T ctx (@0 arg)))
                (val-adr (T [var-adr ctx] (@1 arg))))
            (unless (eq-adr? var-adr val-adr)
              (.op-mov (P: ctx) var-adr val-adr nil)
              (.recycle-pos (F: ctx) val-adr))
            var-adr))]
       (generate-binary-op '#1#add 'op-add)
       (generate-binary-op '#1#sub 'op-sub)
       (generate-binary-op '#1#mul 'op-mul)
       (generate-binary-op '#1#div 'op-div)
       (generate-binary-op '#1#gt  'op-gt)
       (generate-binary-op '#1#lt  'op-lt)
       (generate-binary-op '#1#ge  'op-ge)
       (generate-binary-op '#1#le  'op-le)
       ['#1#not
        (lambda (ctx arg T gtx)
          (let ((adr (tmp-pos-or-parent-adr ctx))
                (in-adr (T ctx (first arg))))
            (.op-not (P: ctx) adr in-adr)
            (.recycle-pos (F: ctx) in-adr)
            adr))]
       ['#1#nil
        (lambda (ctx arg T gtx)
          (let ((adr (.new-tmp-pos (F: ctx))))
          (.op-load-nil (P: ctx) adr)
          adr))]
       ['#1#set
        (lambda (ctx arg T gtx)
          (let ((struct-adr (T ctx (@2 arg)))
                (field-adr  (T ctx (@1 arg)))
                (val-adr    (T ctx (@3 arg))))
            (.op-set (P: ctx) struct-adr field-adr val-adr)
            val-adr))]
       ['#1#get
        (lambda (ctx arg T gtx)
          (let ((out-adr    (tmp-pos-or-parent-adr ctx))
                (field-adr  (T ctx (@0 arg)))
                (struct-adr (T ctx (@1 arg))))
            (.op-get (P: ctx) out-adr struct-adr field-adr)
            out-adr))]
       ['#1#let
        (lambda (ctx arg T gtx)
          (let ((new-vars []))
            (do-each (v (@0 arg))
              (push! new-vars v)
              (push! new-vars (.new-pos (F: ctx))))
            (T (assign ctx [env: (assign (env: ctx) new-vars)]) (@1 arg))))]
       ['#1#map
        (lambda (ctx arg T gtx)
          (let ((map-adrs       [])
                (recycle-adrs   [])
                (map-init-adrs-vec [])
                (ret-adr (tmp-pos-or-parent-adr ctx))
                (map-elements   arg))
            (do-each (map-pair map-elements)
              (let ((key-adr (T ctx (@0 map-pair)))
                    (val-adr (T ctx (@1 map-pair))))
                (push! map-init-adrs-vec (@0 key-adr))
                (push! map-init-adrs-vec (@1 key-adr))
                (push! map-init-adrs-vec (@0 val-adr))
                (push! map-init-adrs-vec (@1 val-adr))
                (push! recycle-adrs key-adr)
                (push! recycle-adrs val-adr)))
            (.op-new-map (P: ctx)
                         ret-adr
                         (.store-static-data (F: ctx) map-init-adrs-vec))
            (.recycle-pos-list (F: ctx) recycle-adrs)
            ret-adr))]
       ['#1#list
        (lambda (ctx arg T gtx)
          (let ((list-adrs      [])
                (recycle-adrs   [])
                (ret-adr (tmp-pos-or-parent-adr ctx)))
            (do-each (a arg)
              (let ((val-adr (T ctx a)))
                (push! recycle-adrs val-adr)
                (push! list-adrs (@0 val-adr))
                (push! list-adrs (@1 val-adr))))
            (.op-new-arg-vec
              (P: ctx)
              ret-adr
              (length arg)
              (.store-static-data (F: ctx) list-adrs))
            (.recycle-pos-list (F: ctx) recycle-adrs)
            ret-adr))]
       ['#1#apply
        (lambda (ctx arg T gtx)
          (let ((fn-adr         (T ctx (@0 arg)))
                (arg-adrs       [])
                (recycle-adrs   [])
                (vec-adr        (.new-tmp-pos (F: ctx)))
                (ret-adr        (tmp-pos-or-parent-adr ctx)))
            (push! recycle-adrs fn-adr)
            (push! recycle-adrs vec-adr)
            (do-each (a (@1 arg))
              (let ((val-adr (T ctx a)))
                (push! recycle-adrs val-adr)
                (push! arg-adrs (@0 val-adr))
                (push! arg-adrs (@1 val-adr))))
            (.op-new-arg-vec
              (P: ctx)
              vec-adr
              (length (@1 arg))
              (.store-static-data (F: ctx) arg-adrs))
            ret-adr
            (.op-call (P: ctx) ret-adr fn-adr vec-adr)
            (.recycle-pos-list (F: ctx) recycle-adrs)
            ret-adr))]
       ['#1#return
        (lambda (ctx arg T gtx)
          (.op-return (P: ctx) (T ctx (@0 arg))))]
       ['#1#create-upv
        (lambda (ctx arg T gtx)
          (let ((new-var-defs []))
            (do-each (upv-var-name (@1 arg))
              (let ((upv-adr (@upv-var-name (env: ctx))))
                (if (= (@1 upv-adr) REG-ROW-UPV)
                  (.op-new-upv (P: ctx) upv-adr upv-adr)
                  (begin
                    (let ((new-upv-adr [(nxt-upv-idx: ctx) REG-ROW-UPV]))
                      (.op-new-upv (P: ctx) new-upv-adr upv-adr)
                      (@!nxt-upv-idx: ctx (+ 1 (nxt-upv-idx: ctx)))
                      (push! new-var-defs upv-var-name)
                      (push! new-var-defs new-upv-adr))))))
            (T (assign ctx
                       [env: (assign (env: ctx)
                                     new-var-defs)])
               (@2 arg))))]
       ['#1#for
        (lambda (ctx arg T gtx)
          (let ((cond-res-adr (.new-tmp-pos (F: ctx)))
                (end-val-adr  (T ctx (@0 (@0 arg))))
                (step-val-adr (T ctx (@1 (@0 arg))))
                (iter-adr     (T ctx (@2 (@0 arg))))
                (for-ret-adr  (.new-tmp-pos (F: ctx)))
                (body-pad     (make-code-pad-object (F: ctx)))
                (body-ret-adr (T (assign ctx [P: body-pad]) (@1 arg))))
            (if (eqv? (@2 body-ret-adr) tmp:)
              (begin
                (.recycle-pos (F: ctx) for-ret-adr)
                (set! for-ret-adr body-ret-adr))
              (.op-mov body-pad for-ret-adr body-ret-adr nil))
            (.op-br           (P: ctx) (.count-ops body-pad))
            (.append-code-pad (P: ctx) body-pad)
            (.op-forinc       (P: ctx)
                              cond-res-adr
                              iter-adr
                              step-val-adr
                              end-val-adr)
            (.op-brnif        (P: ctx)
                              (- 0 (+ 2 (.count-ops body-pad)))
                              cond-res-adr)
            (.recycle-pos (F: ctx) cond-res-adr)
            (.recycle-pos (F: ctx) end-val-adr)
            (.recycle-pos (F: ctx) step-val-adr)
            (.recycle-pos (F: ctx) iter-adr)
            (.recycle-pos (F: ctx) body-ret-adr)
            for-ret-adr))]
       ['#1#if
        (lambda (ctx arg T gtx)
          (let ((is-negated?        (eqv? (first (@0 arg)) '#1#not))
                (cond-adr           (if is-negated?
                                      (T ctx (@1 (@0 arg)))
                                      (T ctx (@0 arg))))
                (true-pad           (make-code-pad-object (F: ctx)))
                (false-pad          (make-code-pad-object (F: ctx)))
                (if-ret-adr         (.new-tmp-pos (F: ctx)))
                (true-branch-adr    (T (assign ctx [P: true-pad])  (@1 arg)))
                (false-branch-adr   (T (assign ctx [P: false-pad]) (@2 arg))))
            (.op-mov true-pad  if-ret-adr true-branch-adr  nil)
            (.op-mov false-pad if-ret-adr false-branch-adr nil)
            (if is-negated?
              (.op-brif         (P: ctx) (+ 1 (.count-ops true-pad)) cond-adr)
              (.op-brnif        (P: ctx) (+ 1 (.count-ops true-pad)) cond-adr))
            (.append-code-pad (P: ctx) true-pad)
            (.op-br           (P: ctx) (.count-ops false-pad))
            (.append-code-pad (P: ctx) false-pad)
            (.recycle-pos (F: ctx) cond-adr)
            (.recycle-pos (F: ctx) true-branch-adr)
            (.recycle-pos (F: ctx) false-branch-adr)
            if-ret-adr))]
       ['#1#lambda
        (lambda (ctx arg T gtx)
          (let ((lambda-spec        (@0 arg))
                (arg-var-adrs       [])
                (lambda-frame       (make-s2-frame gtx))
                (lambda-pad         (make-code-pad-object lambda-frame))
                (is-coroutine       #f #| TODO |#)
                (creator-upv-adrs   [])
                (nxt-upv-idx         0)
                (new-upv-env        {})
                (arity              (if (nil? (@2 lambda-spec))
                                      (length (@1 lambda-spec))
                                      (if (> (length (@1 lambda-spec)) 0)
                                        (- 0 (length (@1 lambda-spec)))
                                        nil))))
            ; handle upvalues we need to collect from creating function:
            (when (list? (@3 lambda-spec))
              (do-each (upv-var-name (@3 lambda-spec))
                (let ((upv-adr (@upv-var-name (env: ctx))))
                  (unless (= (@1 upv-adr) REG-ROW-UPV)
                    (error "Bad upvalue in stage 2 compilation"
                           [upv-var-name lambda-spec]))
                  (push! creator-upv-adrs (@0 upv-adr))
                  (@!upv-var-name new-upv-env [nxt-upv-idx REG-ROW-UPV])
                  (set! nxt-upv-idx (+ 1 nxt-upv-idx)))))
            ; assign new positions to arguments:
            (do-each (param (@1 lambda-spec))
              (push! arg-var-adrs (.new-pos lambda-frame))
              (@!param new-upv-env (last arg-var-adrs)))
            ; handle var-args:
            (unless (nil? (@2 lambda-spec))
              (push! arg-var-adrs (.new-pos lambda-frame))
              (.op-pack-va lambda-pad (last arg-var-adrs) (last arg-var-adrs))
              (@!(@2 lambda-spec) new-upv-env (last arg-var-adrs)))
            ; emit code and compile body with a new environment:
            (define new-env (assign (env: ctx) new-upv-env))
            (let ((body-res-adr
                    (T (assign ctx [P:              lambda-pad
                                    F:              lambda-frame
                                    env:            new-env
                                    nxt-upv-idx:    nxt-upv-idx])
                       (@1 arg)))
                  (ret-adr (tmp-pos-or-parent-adr ctx)))
              (.op-return lambda-pad body-res-adr)
              (.op-new-closure
                (P: ctx)
                ret-adr
                (.store-static-data
                  (F: ctx)
                  (.to-vm-prog lambda-frame lambda-pad))
                (.store-static-data
                  (F: ctx)
                  [is-coroutine arity creator-upv-adrs]))
              ret-adr)))]]
      stage-2-data
      ctx
      gtx)))
;----------------------------------------------------------------------------

(define bukalisp-compile
  (lambda (expr root-env)
    (let ((s1-ctx   {env:         root-env
                     include-dir: "bukalisplib"})
          (s1-gtx   {root-env:    root-env
                     var-counter: 0})
          (s1prog (stage1-transformator
                    (DI! expr (append 'begin expr))
                    s1-ctx
                    s1-gtx)))
      (displayln (pp-str s1prog))
      (let ((gtx {root-env:    {" REGS " (@" REGS " root-env)}})
            (frame (make-s2-frame gtx))
            (ctx {F:            frame
                  P:            (make-code-pad-object frame)
                  env:          {}
                  nxt-upv-idx:  0})
            (adr (stage2-transformer s1prog ctx gtx))
            (P (P: ctx)))
        (.op-return P adr)
;        (displayln DEBUG-INFO: adr (pp-str (.to-vm-prog-debug-info P)))
;        (displayln ROOT-ENV: (pp-str (root-env: gtx)))
        (let ((prog (.to-vm-prog (F: ctx) P)))
          (displayln PROG: prog)
          (run-vm-prog prog (@" REGS " (root-env: gtx))))))))
;----------------------------------------------------------------------------

(define T-env
  (lambda (code expected root-env)
    (set! code (DI! code [code]))
;    (when (nil? env) (set! env [{} []]))
    (let ((r (bukalisp-compile code root-env)))
;      (displayln ROOT_ENV: (pp-str root-env))
      (pp-str root-env)
      (if (eqv? (write-str r) (write-str expected))
        (displayln (str "OK - " code))
        (error (str "Test failed: " code ", returned: " r " != " expected))))))

(define T
  (lambda (code expected)
    (T-env code expected (spawn-root-env))))
;----------------------------------------------------------------------------

;(error X:)
;----------------------------------------------------------------------------

; Test basic (lambda ...) and (let ...)
(T '((lambda (y)
       (let ((x 10))
         (+ x y)))
     13)
   23)

(T '(begin
      (define x 5)
      (+ 1 2 x))
   8)

(T '((lambda (x) (+ x 10)) 11)
   21)

(T '((lambda ()
       (define z 10))) 10)

; Test more basic things:
(T '(+ 1 2 3 4 5 6) 21)

(T '(begin
      (+ 1 123)
      (+ 1 345)
      (+ 1 567))
   568)

(T '(begin 123) 123)
(T '(+ 123)     123)
(T '(+ 1 123)   124)
(T '(begin
      (define x 12)
      (define y 34)
      (+ x y))
   46)
(T '(begin
      (define x 12)
      (define y 34)
      (+ x y))
   46)
(T '(begin
      (define x 12)
      (set! x (+ 14.5 x)))
   26.5)
(T '(begin
      (define x +)
      (set! x (x 1.5 1)))
   2.5)

(T '(* 2 3 4)          24)

(T '(> (atom-id []) 0) #true)

; Test var-args:
(T '((lambda (. x) x) 1 2 3) '(1 2 3))

(T '((lambda (. x) x))              [])
(T '((lambda (. x) x) 1 2 3)        [1 2 3])
(T '((lambda (a . x) [a x]) 1 2 3)  [1 [2 3]])
(T '((lambda (a . x) [a x]) 1)      [1 []])
(T '((lambda (a . x) [a x]) nil)    [nil []])
(T '(begin
      (define (x a . v) [a v])
      (x 1 2 3))
   [1 [2 3]])

; Test upvalues and closures
(T '((lambda (x) x) 5)
   5)

(T '((lambda (x y)
       (+ 1 ((lambda () x))))
     5 nil)
   6)

(T '((lambda (x)
       ((lambda (y) (+ x y))
        10))
     5)
   15)

(T '(begin (define x 0)
           (define (o a)
             (set! x (+ x a)))
           (for (i 1 1000000)
             (o 1)))
   1000000)

(T '((((let ((x 10))
         (lambda (y)
           (lambda (j)
             (let ((v (+ y j x)))
               (lambda ()
                 (+
                   ((lambda () (+ v x)))
                   v
                   x
                   j
                   y)))))) 1) 2))
   49)

; Test weird (define ...)s:
(T '(let ((x (begin
               (define y 20)
               (+ 10 y))))
      (define o 20)
      (+ y x o))
   70)
(T '(let ((x 1))
      (define o 10)
      (+ o x))
   11)

; Test (for ...), upvalues and closures:
(T '(begin (define x 0)
           (define (o a)
             (set! x (+ x a)))
           (for (i 1 1000000)
             (o 1)))
   1000000)

(T '(let ((x 0))
      (define (o a)
        (set! x (+ x a)))
      (for (i 1 1000000)
        (o 1)))
   1000000)

(T '(let ((x 0)
          (y 0))
      (define (o a fn-i)
        (set! x (+ x a))
        (set! y (+ y (fn-i))))
      (for (i 1 100000)
        (o 1 (lambda () i)))
      [x y])
   [100000 5000050000])

(T '(let ((x 0)
          (y 0))
      (define (o a fn-i)
        (set! x (+ x a))
        (set! y (+ y (fn-i))))
      (for (i 1 100000)
        (let ((j i))
          (o 1 (lambda () j))))
      [x y])
   [100000 5000050000])

; Test when and unless:
(T '(when   #t 10) 10)
(T '(when   #f 10) nil)
(T '(unless #t 10) nil)
(T '(unless #f 10) 10)

; Test basic variable handling:
(T '(begin (define y 30) y) 30)
(T '(begin (define x 12)
           (define y 30)
           (set! y 10)
           y) 10)

; Test data loading:
(T 'a: a:)
(T '[1 2 3] '(1 2 3))
(T '{x: 12} {x: 12})
(T ''{x: 12} {x: 12})
(T '{x: (+ 6 2)} {x: 8})
(T ''(1 2 3) '(1 2 3))
(T ''(eq? 1 2) '(eq? 1 2))

; Test arithmetics:
(T '(+ 1 2 3) 6)
(T '(+ 1.2 2 3) 6.2)
(T '(* 1.2 2 3) 7.2)
(T '(/ 8 2 2) 2)
(T '(/ 5 2) 2)
(T '(- 10.5 1.3 2.2) 7)
(T '(< 1 2) #true)
(T '(> 1 2) #false)
(T '(<= 1 2) #true)
(T '(<= 1 2) #true)
(T '(<= 2 2) #true)
(T '(<= 2.1 2) #false)
(T '(>= 2.1 2) #true)

; Test procedures:
(T '(eqv? #t #t) #true)
(T '(eqv? #f #f) #true)
(T '(eqv? #t #f) #false)

(T '(eqv? a: a:) #true)
(T '(eqv? a: b:) #false)

(T '(eqv? 'a 'a) #true)
(T '(eqv? 'a 'b) #false)

(T '(eqv? 2 (/ 4 2)) #true)
(T '(eqv? 2 (/ 4.0 2.0)) #false)
(T '(eqv? 2.0 (/ 4.0 2.0)) #true)

(T '(eqv? [] []) #false)
(T '(eqv? {} {}) #false)
(T '(eqv? { x: 11 } { x: 10 }) #false)
(T '(eqv? 2 (/ 5 2)) #true)
(T '(eqv? 2 (/ 5.0 2)) #false)
(T '(eqv? #f 0) #false)
(T '(eqv? #f []) #false)
(T '(eqv? 2.0 2) #false)

(T '(eqv? + (let ((y +)) y)) #true)
(T '(eqv? + (let ((o +)) (let ((y +)) y o))) #true)
(T '(let ((m { x: 11 }) (l #f)) (set! l m) (eqv? m l)) #true)

(T '(not #t) #false)
(T '(not 1) #false)
(T '(not '()) #false)
(T '(not #f) #true)

; Testing predicates
(T '(symbol? 'a) #true)
(T '(symbol? a:) #false)
(T '(symbol? 1) #false)

(T '(keyword? a:) #true)
(T '(keyword? 'a) #false)
(T '(keyword? 1) #false)

(T '(nil? 1) #false)
(T '(nil? 0) #false)
(T '(nil? []) #false)
(T '(nil? nil) #true)

(T '(exact? nil) #false)
(T '(exact? 123) #true)
(T '(exact? 1.0) #false)

(T '(inexact? nil) #false)
(T '(inexact? 123) #false)
(T '(inexact? 1.0) #true)

(T '(number? 'x)            #false)
(T '(number? x:)            #false)
(T '(number? [1 2 3])       #false)
(T '(number? { a: 1 b: 2 }) #false)
(T '(number? [])            #false)
(T '(number? {})            #false)
(T '(number? #true)         #false)
(T '(number? #false)        #false)
(T '(number? nil)           #false)
(T '(number? 1)             #true)
(T '(number? "abc")         #false)

(T '(string? 1) #false)
(T '(string? a:) #false)
(T '(string? 'a) #false)
(T '(string? "foo") #true)
(T '(boolean? "foo") #false)
(T '(boolean? #t) #true)
(T '(boolean? #f) #true)
(T '(boolean? nil) #false)

(T '(list? nil) #false)
(T '(list? []) #true)
(T '(list? '()) #true)
(T '(list? string?) #false)
(T '(list? {}) #false)

(T '(map? {}) #true)
(T '(map? '()) #false)
(T '(map? []) #false)
(T '(map? nil) #false)

(T '(procedure? string?) #true)
(T '(procedure? (lambda (x) x)) #true)
;(T '(procedure? if) #false)
(T '(procedure? '()) #false)

(T '(symbol? 'x)             '#true)
(T '(symbol? x:)             '#false)
(T '(symbol? [1 2 3])        '#false)
(T '(symbol? { a: 1 b: 2 })  '#false)
(T '(symbol? [])             '#false)
(T '(symbol? {})             '#false)
(T '(symbol? #true)          '#false)
(T '(symbol? #false)         '#false)
(T '(symbol? nil)            '#false)
(T '(symbol? 1)              '#false)
(T '(symbol? "abc")          '#false)

(T '(keyword? 'x)            '#false)
(T '(keyword? x:)            '#true)
(T '(keyword? [1 2 3])       '#false)
(T '(keyword? { a: 1 b: 2 }) '#false)
(T '(keyword? {})            '#false)
(T '(keyword? [])            '#false)
(T '(keyword? #true)         '#false)
(T '(keyword? #false)        '#false)
(T '(keyword? nil)           '#false)
(T '(keyword? 1)             '#false)
(T '(keyword? "abc")         '#false)

(T '(list? 'x)               '#false)
(T '(list? x:)               '#false)
(T '(list? [1 2 3])          '#true)
(T '(list? { a: 1 b: 2 })    '#false)
(T '(list? [])               '#true)
(T '(list? {})               '#false)
(T '(list? #true)            '#false)
(T '(list? #false)           '#false)
(T '(list? nil)              '#false)
(T '(list? 1)                '#false)
(T '(list? "abc")            '#false)

(T '(map? 'x)                '#false)
(T '(map? x:)                '#false)
(T '(map? [1 2 3])           '#false)
(T '(map? { a: 1 b: 2 })     '#true)
(T '(map? [])                '#false)
(T '(map? {})                '#true)
(T '(map? #true)             '#false)
(T '(map? #false)            '#false)
(T '(map? nil)               '#false)
(T '(map? 1)                 '#false)
(T '(map? "abc")             '#false)

(T '(string? 'x)             '#false)
(T '(string? x:)             '#false)
(T '(string? [1 2 3])        '#false)
(T '(string? { a: 1 b: 2 })  '#false)
(T '(string? [])             '#false)
(T '(string? {})             '#false)
(T '(string? #true)          '#false)
(T '(string? #false)         '#false)
(T '(string? nil)            '#false)
(T '(string? 1)              '#false)
(T '(string? "abc")          '#true)

(T '(boolean? 'x)            '#false)
(T '(boolean? x:)            '#false)
(T '(boolean? [1 2 3])       '#false)
(T '(boolean? { a: 1 b: 2 }) '#false)
(T '(boolean? [])            '#false)
(T '(boolean? {})            '#false)
(T '(boolean? #true)         '#true)
(T '(boolean? #false)        '#true)
(T '(boolean? nil)           '#false)
(T '(boolean? 1)             '#false)
(T '(boolean? "abc")         '#false)

(T '(nil? 'x)                '#false)
(T '(nil? x:)                '#false)
(T '(nil? [1 2 3])           '#false)
(T '(nil? { a: 1 b: 2 })     '#false)
(T '(nil? [])                '#false)
(T '(nil? {})                '#false)
(T '(nil? #true)             '#false)
(T '(nil? #false)            '#false)
(T '(nil? nil)               '#true)
(T '(nil? 1)                 '#false)
(T '(nil? "abc")             '#false)

; Test (type ...):
(T '(let ((m { 'nil 1234 }))
      (@(type nil) m))
   nil)

(T '(let ((m { (type nil) 1234 }))
      (@(type nil) m))
   1234)

(T '(type []) 'list)
(T '(type [1 2 3]) 'list)
(T '(type '()) 'list)
(T '(type '(1 2 3)) 'list)
(T '(type {}) 'map)
(T '(type map?) 'procedure)
(T '(type (lambda () nil)) 'procedure)
(T '(type 1) 'exact)
(T '(type 1.0) 'inexact)
(T '(type nil) 'nil)
(T '(type #t) 'boolean)
(T '(type #f) 'boolean)
(T '(type 'f) 'symbol)
(T '(type f:) 'keyword)
(T '(type "f") 'string)

; Test 'length' primitive
(T '(length [1 2 3]) 3)
(T '(length []) 0)
(T '(length '()) 0)
(T '(length {}) 0)
(T '(length {x: 12}) 1)
(T '(length {y: 324 x: 12}) 2)
(T '(length (let ((l [])) (@!9 l l))) 10)

(T '(length (list 1 2 3)) 3)
(T '(length (list)) 0)
(T '(if (>  (length (list 1 2 3)) 3) "yes" "no") "no")
(T '(if (>= (length (list 1 2 3)) 3) "yes" "no") "yes")
(T '(begin (let ((c length)) (c [1 2 3 (define x 20)]))) 4)
(T '(begin (length [1 2 3 (define x 20)]) x) 20)
(T '(begin [1 2 3 (define x 20)] x) 20)

; Test other primitives:
(T '(first '(a b c)) 'a)
(T '(first '()) 'nil)
(T '(first [3]) '3)
(T '(last [1 2 3]) '3)
(T '(last [3]) '3)
(T '(last []) 'nil)
(T '(take [x: y: 12 3 4] 2) '(x: y:))
(T '(take [1] 2) '(1))
(T '(take [1 2] 2) '(1 2))
(T '(take [] 2) '())
(T '(drop [1 2 3] 2) '(3))
(T '(drop [1 2 3] 4) '())
(T '(drop [1 2 3] 3) '())
(T '(drop [] 3) '())
(T '(drop [1 2 3] 0) '(1 2 3))
(T '(drop [1 2 3] 1) '(2 3))
(T '(append [1 2 3] 1 a: { x: 12 } [5 5 5]) '(1 2 3 1 a: x: 12 5 5 5))
(T '(append [1 2 3]) '(1 2 3))

; Test system primitives:
(T '(sys-slurp-file "foo.txt") "xxx\n")

; Test let TODO: Moar!
(T '(let ((x 10)) x) 10)

; Test some assignment stuff:
(T '(begin
      (define x 0)
      (set! x (+ x 1 2 3 4 5))) 15)
(T '(begin
      (define x 0)
      (set! x (not x)))
   #f)

; Testing big lambda applications:
(T '((lambda (x)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)) 9)
   9)

(T '((lambda (x)   (+ x 1)) 1.5) 2.5)
(T '((lambda (x y) (+ (* x y) 1)) 1.5 4) 7.0)
(T '((lambda (x y _ _ _) (+ (* x y) 1)) 1.5 4 e: r: g:) 7.0)
(T '((lambda (x)
       ((lambda (y) (+ x y))
        10))
     5)
   15)
(T '((lambda (x)
       ((lambda (y) (+ 1 0 3 30 30 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10))
     5) 16)

(T '(let ((x [])
          (c 10))
      (set! c (lambda (o) (push! x o)))
      (c 1)
      (c 2)
      x)
   [1 2])

; Test recursive calling:
(T '(let ((x [])
          (c 11))
      (set! c
        (lambda (o)
          (push! x o)
          (when (eqv? o 0)
            (return 11))
          (c (- o 1))))
      (c 2)
      x)
   [2 1 0])

; Test define
(T '(begin (define x 10) x)     10)
(T '(begin (define (x) 10) (x)) 10)
(T '(begin
      (define (x b c)
        (+ (* b c) 10))
      (x 2.5 10))
   35)
(T '(begin (define x 10) (define x 20) x) 20)
(T '(begin (define x 10) (define y 20) (define x 21) [x y]) '(21 20))
(T '(begin (define x 10) (define y 20) (define x y) x) 20)
(T '(begin (define if 10) if) 10)


; Test varargs
(T '((lambda (. x) x))              [])
(T '((lambda (. x) x) 1 2 3)        [1 2 3])
(T '((lambda (a . x) [a x]) 1 2 3)  [1 [2 3]])
(T '((lambda (a . x) [a x]) 1)      [1 []])
(T '((lambda (a . x) [a x]) nil)    [nil []])
(T '(begin
      (define (x a . v) [a v])
      (x 1 2 3))
   [1 [2 3]])

(T '(begin
      (define (x a . v)
        (define z v)
        [a z])
      (x 1 2 3))
   [1 [2 3]])

; Test using a known environemt which is mutatable:
(let ((my-env (spawn-root-env)))
  (T-env '(begin (define x 13.3)) 13.3 my-env)
  (T-env '(begin x)               13.3 my-env)
  (T-env '(define y x)            13.3 my-env)
  (T-env '(+ x y)                 26.6 my-env))
