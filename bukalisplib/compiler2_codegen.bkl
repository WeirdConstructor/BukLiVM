;----------------------------------------------------------------------------

(include compiler2)
(include code-pad)

;----------------------------------------------------------------------------

(define REG-ROW-FRAME 0)
(define REG-ROW-DATA  1)
(define REG-ROW-PRIM  2)
(define REG-ROW-UPV   3)
(define REG-ROW-ROOT  4)

;----------------------------------------------------------------------------

(define eq-adr?
  (lambda (a b)
    (and (eqv? (@0 a) (@0 b))
         (eqv? (@1 a) (@1 b)))))
;----------------------------------------------------------------------------

(define tmp-pos-or-parent-adr
  (lambda (ctx)
    (if (@parent-ctx: ctx)
      (@parent-ctx: ctx)
      (.new-tmp-pos (F: ctx)))))
;----------------------------------------------------------------------------

(define make-s2-frame
  (lambda (gtx)
    (let ((self {pad: []
                 pos: [0 []]}))
      ($define! self (get-debug-info)
        (last (meta-stack: gtx)))
      ($define! self (store-static-data data)
        (push! (pad: self) data)
        [(- (length (pad: self)) 1) REG-ROW-DATA])
      ($define! self (to-vm-prog code-pad)
        (make-vm-prog [(pad:  self)
                       (.to-vm-prog-code       code-pad)
                       (.to-vm-prog-debug-info code-pad)]))
      ($define! self (new-tmp-pos)
        (let ((env-pos           (pos: self))
              (free-tmp-pos-list (@1 env-pos)))
          (if (> (length free-tmp-pos-list) 0)
            [(pop! free-tmp-pos-list) REG-ROW-FRAME tmp:]
            (let ((new-pos (@0 env-pos)))
              (@!0 env-pos (+ new-pos 1))
              [new-pos REG-ROW-FRAME tmp:]))))
      ($define! self (new-pos)
        (let ((env-pos (pos: self))
              (new-pos (@0 env-pos)))
          (@!0 env-pos (+ 1 new-pos))
          [new-pos REG-ROW-FRAME]))
      ($define! self (recycle-pos-list pos-list)
        (do-each (pos pos-list)
          (.recycle-pos self pos)))
      ($define! self (recycle-pos pos)
        (when (eqv? (@2 pos) tmp:)
          (@!2 pos nil) ; mark it as non-tmp, as we already put it on the free-list
          (push! (@1 (pos: self)) (@0 pos)))
        pos)
      self)))
;----------------------------------------------------------------------------

(define generate-binary-op
  (lambda (node-sym op-gen-sym)
    [node-sym
      (lambda (ctx arg T gtx)
        (let ((out-adr (tmp-pos-or-parent-adr ctx))
              (a-adr  (T ctx (@0 arg)))
              (b-adr  (T ctx (@1 arg))))
          (.(begin op-gen-sym) (P: ctx) out-adr a-adr b-adr)
          (.recycle-pos (F: ctx) a-adr)
          (.recycle-pos (F: ctx) b-adr)
          out-adr))]))
;----------------------------------------------------------------------------

;(define optimize-out-adr!
;  (lambda (ctx out-adr in-adr)
;    (if (and
;          (eqv? (@1 out-adr) REG-ROW-FRAME)
;          (eqv? (@1 in-adr)  REG-ROW-FRAME))
;      (if (eqv? (@2 in-adr) tmp:)
;        (begin
;          (.recycle-pos (F: ctx) out-adr)
;          (@!0 out-adr (@0 in-adr))
;          (@!1 out-adr (@1 in-adr))
;          (@!2 out-adr (@2 in-adr))
;          in-adr)
;        (begin
;          (.recycle-pos (F: ctx) in-adr)
;          out-adr))
;      out-adr)))
;----------------------------------------------------------------------------

(define primitive-map (bkl-primitive-map))

(define stage2-transformer
  (lambda (stage-2-data ctx gtx)
    (find-transform-match
      [['#1#data
        (lambda (ctx arg T gtx)
          (.store-static-data (F: ctx) (first arg)))]
       ['#1#prim
        (lambda (ctx arg T gtx)
          (let ((prim-idx (@(first arg) primitive-map)))
            (unless prim-idx
              (error "Bad primitive in stage 2 compilation" arg))
            [prim-idx REG-ROW-PRIM]))]
       ['#1#begin
        (lambda (ctx arg T gtx)
          (define last-adr nil)
          (do-each (form arg)
            (when last-adr
              (.recycle-pos (F: ctx) last-adr))
            (let ((adr (T ctx form)))
              (set! last-adr adr))
            last-adr))]
       ['#1#var
        (lambda (ctx arg T gtx)
          (let ((adr (@(@0 arg) (env: ctx))))
            (unless adr
              (error "Fatal error in stage 2, variable not found!" arg))
            adr))]
       ['#1#glob-var
        (lambda (ctx arg T gtx)
          (let ((root-var  (@(@0 arg) (root-env: gtx))))
            (unless root-var
              (let ((new-root-adr (@1 arg)))
                (set! root-var [new-root-adr REG-ROW-ROOT])
                (@!(@0 arg) (root-env: gtx) root-var)))
            root-var))]
       ['#1#set!
        (lambda (ctx arg T gtx)
          (let ((var-adr (T ctx (@0 arg)))
                (val-adr (T [var-adr ctx] (@1 arg))))
            (unless (eq-adr? var-adr val-adr)
              (.op-mov (P: ctx) var-adr val-adr nil)
              (.recycle-pos (F: ctx) val-adr))
            var-adr))]
       (generate-binary-op '#1#add 'op-add)
       (generate-binary-op '#1#sub 'op-sub)
       (generate-binary-op '#1#mul 'op-mul)
       (generate-binary-op '#1#div 'op-div)
       (generate-binary-op '#1#gt  'op-gt)
       (generate-binary-op '#1#lt  'op-lt)
       (generate-binary-op '#1#ge  'op-ge)
       (generate-binary-op '#1#le  'op-le)
       (generate-binary-op '#1#eq  'op-eq)
       ['#1#not
        (lambda (ctx arg T gtx)
          (let ((adr (tmp-pos-or-parent-adr ctx))
                (in-adr (T ctx (first arg))))
            (.op-not (P: ctx) adr in-adr)
            (.recycle-pos (F: ctx) in-adr)
            adr))]
       ['#1#nil
        (lambda (ctx arg T gtx)
          (let ((adr (.new-tmp-pos (F: ctx))))
          (.op-load-nil (P: ctx) adr)
          adr))]
       ['#1#set
        (lambda (ctx arg T gtx)
          (let ((struct-adr (T ctx (@2 arg)))
                (field-adr  (T ctx (@1 arg)))
                (val-adr    (T ctx (@3 arg))))
            (.op-set (P: ctx) struct-adr field-adr val-adr)
            val-adr))]
       ['#1#get
        (lambda (ctx arg T gtx)
          (let ((out-adr    (tmp-pos-or-parent-adr ctx))
                (field-adr  (T ctx (@0 arg)))
                (struct-adr (T ctx (@1 arg))))
            (.op-get (P: ctx) out-adr struct-adr field-adr)
            out-adr))]
       ['#1#let
        (lambda (ctx arg T gtx)
          (let ((new-vars []))
            (do-each (v (@0 arg))
              (push! new-vars v)
              (push! new-vars (.new-pos (F: ctx))))
            (T (assign ctx [env: (assign (env: ctx) new-vars)]) (@1 arg))))]
       ['#1#map
        (lambda (ctx arg T gtx)
          (let ((map-adrs       [])
                (recycle-adrs   [])
                (map-init-adrs-vec [])
                (ret-adr (tmp-pos-or-parent-adr ctx))
                (map-elements   arg))
            (do-each (map-pair map-elements)
              (let ((key-adr (T ctx (@0 map-pair)))
                    (val-adr (T ctx (@1 map-pair))))
                (push! map-init-adrs-vec (@0 key-adr))
                (push! map-init-adrs-vec (@1 key-adr))
                (push! map-init-adrs-vec (@0 val-adr))
                (push! map-init-adrs-vec (@1 val-adr))
                (push! recycle-adrs key-adr)
                (push! recycle-adrs val-adr)))
            (.op-new-map (P: ctx)
                         ret-adr
                         (.store-static-data (F: ctx) map-init-adrs-vec))
            (.recycle-pos-list (F: ctx) recycle-adrs)
            ret-adr))]
       ['#1#list
        (lambda (ctx arg T gtx)
          (let ((list-adrs      [])
                (recycle-adrs   [])
                (ret-adr (tmp-pos-or-parent-adr ctx)))
            (do-each (a arg)
              (let ((val-adr (T ctx a)))
                (push! recycle-adrs val-adr)
                (push! list-adrs (@0 val-adr))
                (push! list-adrs (@1 val-adr))))
            (.op-new-arg-vec
              (P: ctx)
              ret-adr
              (length arg)
              (.store-static-data (F: ctx) list-adrs))
            (.recycle-pos-list (F: ctx) recycle-adrs)
            ret-adr))]
       ['#1#apply
        (lambda (ctx arg T gtx)
          (let ((fn-adr         (T ctx (@0 arg)))
                (arg-adrs       [])
                (recycle-adrs   [])
;                (vec-adr        (.new-tmp-pos (F: ctx)))
                (ret-adr        (tmp-pos-or-parent-adr ctx)))
            (push! recycle-adrs fn-adr)
;            (push! recycle-adrs vec-adr)
            (do-each (a (@1 arg))
              (let ((val-adr (T ctx a)))
                (push! recycle-adrs val-adr)
                (push! arg-adrs (@0 val-adr))
                (push! arg-adrs (@1 val-adr))))
;            (.op-new-arg-vec
;              (P: ctx)
;              vec-adr
;              (length (@1 arg))
;              (.store-static-data (F: ctx) arg-adrs))
;            (.op-new-arg-vec
;              (P: ctx)
;              vec-adr
;              (length (@1 arg))
;              )
            ret-adr
            (.op-call (P: ctx) ret-adr fn-adr (.store-static-data (F: ctx) arg-adrs))
            (.recycle-pos-list (F: ctx) recycle-adrs)
            ret-adr))]
       ['#1#return
        (lambda (ctx arg T gtx)
          (.op-return (P: ctx) (T ctx (@0 arg))))]
       ['#1#create-upv
        (lambda (ctx arg T gtx)
          (let ((new-var-defs []))
            (do-each (upv-var-name (@1 arg))
              (let ((upv-adr (@upv-var-name (env: ctx))))
                (if (= (@1 upv-adr) REG-ROW-UPV)
                  (.op-new-upv (P: ctx) upv-adr upv-adr)
                  (begin
                    (let ((new-upv-adr [(nxt-upv-idx: ctx) REG-ROW-UPV]))
                      (.op-new-upv (P: ctx) new-upv-adr upv-adr)
                      (@!nxt-upv-idx: ctx (+ 1 (nxt-upv-idx: ctx)))
                      (push! new-var-defs upv-var-name)
                      (push! new-var-defs new-upv-adr))))))
            (T (assign ctx
                       [env: (assign (env: ctx)
                                     new-var-defs)])
               (@2 arg))))]
       ['#1#for
        (lambda (ctx arg T gtx)
          (let ((cond-res-adr (.new-tmp-pos (F: ctx)))
                (end-val-adr  (T ctx (@0 (@0 arg))))
                (step-val-adr (T ctx (@1 (@0 arg))))
                (iter-adr     (T ctx (@2 (@0 arg))))
                (ret-adr      (.new-tmp-pos (F: ctx)))
                (body-pad     (make-code-pad-object (F: ctx)))
                (body-ret-adr (T (assign ctx [P: body-pad]) (@1 arg))))
            (if (eqv? (@2 body-ret-adr) tmp:)
              (begin
                (.recycle-pos (F: ctx) ret-adr)
                (set! ret-adr body-ret-adr))
              (.op-mov body-pad ret-adr body-ret-adr nil))
            (.op-br           (P: ctx) (.count-ops body-pad))
            (.append-code-pad (P: ctx) body-pad)
            (.op-forinc       (P: ctx)
                              cond-res-adr
                              iter-adr
                              step-val-adr
                              end-val-adr)
            (.op-brnif        (P: ctx)
                              (- 0 (+ 2 (.count-ops body-pad)))
                              cond-res-adr)
            (.recycle-pos (F: ctx) cond-res-adr)
            (.recycle-pos (F: ctx) end-val-adr)
            (.recycle-pos (F: ctx) step-val-adr)
            (.recycle-pos (F: ctx) iter-adr)
            (.recycle-pos (F: ctx) body-ret-adr)
            ret-adr))]
       ['#1#while
        (lambda (ctx arg T gtx)
          (let ((cond-pad       (make-code-pad-object (F: ctx)))
                (cond-adr       (T (assign ctx [P: cond-pad]) (@0 arg)))
                (ret-adr        (.new-tmp-pos (F: ctx)))
                (body-pad       (make-code-pad-object (F: ctx)))
                (body-ret-adr   (T (assign ctx [P: body-pad]) (@1 arg))))
            (if (eqv? (@2 body-ret-adr) tmp:)
              (begin
                (.recycle-pos (F: ctx) ret-adr)
                (set! ret-adr body-ret-adr))
              (.op-mov body-pad ret-adr body-ret-adr nil))
            (.op-br           (P: ctx) (.count-ops body-pad))
            (.append-code-pad (P: ctx) body-pad)
            (.append-code-pad (P: ctx) cond-pad)
            (.op-brif (P: ctx)
                      (- 0
                         (+ 1
                            (.count-ops cond-pad)
                            (.count-ops body-pad)))
                      cond-adr)
            (.recycle-pos (F: ctx) cond-adr)
            ret-adr))]
       ['#1#do-each

;         (define ret-adr (.new-tmp-pos self))
;         (.push-env self)
;         (let ((body-pad    (.make-code-pad self))
;               (map-adr     (.compile self obj-atom code-pad))
;               (ok-adr      (.new-pos self))
;               (val-adr     (.new-pos self))
;               (iter-adr    (.new-pos self))
;               (key-adr     nil)
;               (with-key?   (eqv? (length iter-desc) 3)))
;           ; initialization:
;           (if with-key?
;             (begin
;               (.define-var self (@1 iter-desc) [var: (@0 val-adr)])
;               (set! key-adr (.new-pos self))
;               (.define-var self (@0 iter-desc)
;                            [var: (@0 key-adr)]))
;             (.define-var self (@0 iter-desc) [var: (@0 val-adr)]))
;           (define body-ret-adr
;                   (.compile-block self (drop atom 2) body-pad))
;           (.op-load-nil code-pad ret-adr)
;           ; start iteration:
;           (.op-iter     code-pad iter-adr map-adr)
;           (.op-next     code-pad ok-adr val-adr iter-adr)
;           (when with-key?
;             (.op-ikey code-pad key-adr iter-adr))
;           ; branch:
;           (define body-op-count (.count-ops body-pad))
;           (.op-br  code-pad (+ 2 body-op-count))
;           (.append-code-pad code-pad body-pad)
;           (.op-mov code-pad ret-adr body-ret-adr nil)
;           (.op-next  code-pad ok-adr val-adr iter-adr)
;           (when with-key?
;             (.op-ikey code-pad key-adr iter-adr))
;           (.op-brnif code-pad
;                      (- 0 (+ (if with-key? 4 3)
;                              body-op-count))
;                      ok-adr)
;           ; cleanup:
;           (.pop-env self)
;           ret-adr)))
        (lambda (ctx arg T gtx)
          (let ((body-pad       (make-code-pad-object (F: ctx)))
                (body-ret-adr   (T (assign ctx [P: body-pad]) (@2 arg)))
                (struct-adr     (T ctx (@1 arg)))
                (ret-adr        (.new-tmp-pos (F: ctx)))
                (ok-adr         (.new-tmp-pos (F: ctx)))
                (val-adr        (T ctx (@0 (@0 arg))))
                (iter-adr       (.new-tmp-pos (F: ctx)))
                (key-adr        nil))
            (when (@1 (@0 arg))
              (set! key-adr (T ctx (@1 (@0 arg)))))
            (if (eqv? (@2 body-ret-adr) tmp:)
              (begin
                (.recycle-pos (F: ctx) ret-adr)
                (set! ret-adr body-ret-adr))
              (.op-mov body-pad ret-adr body-ret-adr nil))
            (.op-load-nil (P: ctx) ret-adr)
            (.op-iter  (P: ctx) iter-adr struct-adr)
            (.op-next  (P: ctx) ok-adr val-adr iter-adr)
            (when key-adr
              (.op-ikey (P: ctx) key-adr iter-adr))
            (.op-br    (P: ctx) (+ (if key-adr 2 1)
                                   (.count-ops body-pad)))
            (.append-code-pad (P: ctx) body-pad)
            (.op-next  (P: ctx) ok-adr val-adr iter-adr)
            (when key-adr
              (.op-ikey (P: ctx) key-adr iter-adr))
            (.op-brnif (P: ctx) (- 0 (+ (if key-adr 3 2)
                                        (.count-ops body-pad)))
                       ok-adr)
            (.recycle-pos (F: ctx) struct-adr)
            (.recycle-pos (F: ctx) ok-adr)
            (.recycle-pos (F: ctx) val-adr)
            (.recycle-pos (F: ctx) iter-adr)
            (when key-adr
              (.recycle-pos (F: ctx) key-adr))
            ret-adr))]
       ['#1#if
        (lambda (ctx arg T gtx)
          (let ((is-negated?        (eqv? (first (@0 arg)) '#1#not))
                (cond-adr           (if is-negated?
                                      (T ctx (@1 (@0 arg)))
                                      (T ctx (@0 arg))))
                (true-pad           (make-code-pad-object (F: ctx)))
                (false-pad          (make-code-pad-object (F: ctx)))
                (if-ret-adr         (tmp-pos-or-parent-adr ctx))
                (true-branch-adr    (T (assign ctx [P: true-pad])  (@1 arg)))
                (false-branch-adr   (T (assign ctx [P: false-pad]) (@2 arg))))
            (.op-mov true-pad  if-ret-adr true-branch-adr  nil)
            (.op-mov false-pad if-ret-adr false-branch-adr nil)
            (if is-negated?
              (.op-brif         (P: ctx) (+ 1 (.count-ops true-pad)) cond-adr)
              (.op-brnif        (P: ctx) (+ 1 (.count-ops true-pad)) cond-adr))
            (.append-code-pad (P: ctx) true-pad)
            (.op-br           (P: ctx) (.count-ops false-pad))
            (.append-code-pad (P: ctx) false-pad)
            (.recycle-pos (F: ctx) cond-adr)
            (.recycle-pos (F: ctx) true-branch-adr)
            (.recycle-pos (F: ctx) false-branch-adr)
            if-ret-adr))]
       ['#1#lambda
        (lambda (ctx arg T gtx)
          (let ((lambda-spec        (@0 arg))
                (arg-var-adrs       [])
                (lambda-frame       (make-s2-frame gtx))
                (lambda-pad         (make-code-pad-object lambda-frame))
                (is-coroutine       #f #| TODO |#)
                (creator-upv-adrs   [])
                (nxt-upv-idx         0)
                (new-upv-env        {})
                (arity              (if (nil? (@2 lambda-spec))
                                      (length (@1 lambda-spec))
                                      (if (> (length (@1 lambda-spec)) 0)
                                        (- 0 (length (@1 lambda-spec)))
                                        nil))))
            ; handle upvalues we need to collect from creating function:
            (when (list? (@3 lambda-spec))
              (do-each (upv-var-name (@3 lambda-spec))
                (let ((upv-adr (@upv-var-name (env: ctx))))
                  (unless (= (@1 upv-adr) REG-ROW-UPV)
                    (error "Bad upvalue in stage 2 compilation"
                           [upv-var-name lambda-spec]))
                  (push! creator-upv-adrs (@0 upv-adr))
                  (@!upv-var-name new-upv-env [nxt-upv-idx REG-ROW-UPV])
                  (set! nxt-upv-idx (+ 1 nxt-upv-idx)))))
            ; assign new positions to arguments:
            (do-each (param (@1 lambda-spec))
              (push! arg-var-adrs (.new-pos lambda-frame))
              (@!param new-upv-env (last arg-var-adrs)))
            ; handle var-args:
            (unless (nil? (@2 lambda-spec))
              (push! arg-var-adrs (.new-pos lambda-frame))
              (.op-pack-va lambda-pad (last arg-var-adrs) (last arg-var-adrs))
              (@!(@2 lambda-spec) new-upv-env (last arg-var-adrs)))
            ; emit code and compile body with a new environment:
            (define new-env (assign (env: ctx) new-upv-env))
            (let ((body-res-adr
                    (T (assign ctx [P:              lambda-pad
                                    F:              lambda-frame
                                    env:            new-env
                                    nxt-upv-idx:    nxt-upv-idx])
                       (@1 arg)))
                  (ret-adr (tmp-pos-or-parent-adr ctx)))
              (.op-return lambda-pad body-res-adr)
              (.op-new-closure
                (P: ctx)
                ret-adr
                (.store-static-data
                  (F: ctx)
                  (.to-vm-prog lambda-frame lambda-pad))
                (.store-static-data
                  (F: ctx)
                  [is-coroutine arity creator-upv-adrs]))
              ret-adr)))]]
      stage-2-data
      ctx
      gtx)))
;----------------------------------------------------------------------------
(define *DEBUG* #f)
(define PUSH-DEBUG (lambda () (set! *DEBUG* #t)))
(define POP-DEBUG (lambda () (set! *DEBUG* #t)))

(define bukalisp-compile
  (lambda (expr root-env execute?)
    (let ((s1-ctx   {env:         root-env
                     include-dir: "bukalisplib"})
          (s1-gtx   {root-env:    root-env
                     var-counter: 0})
          (s1prog (stage1-transformator
                    (DI! expr (append 'begin expr))
                    s1-ctx
                    s1-gtx)))
      (when *DEBUG* (displayln (pp-str s1prog)))
      (let ((gtx {root-env:    {" REGS " (@" REGS " root-env)}})
            (frame (make-s2-frame gtx))
            (ctx {F:            frame
                  P:            (make-code-pad-object frame)
                  env:          {}
                  nxt-upv-idx:  0})
            (adr (stage2-transformer s1prog ctx gtx))
            (P (P: ctx)))
        (.op-return P adr)
;        (displayln DEBUG-INFO: adr (pp-str (.to-vm-prog-debug-info P)))
;        (displayln ROOT-ENV: (pp-str (root-env: gtx)))
        (let ((prog (.to-vm-prog (F: ctx) P)))
          (when *DEBUG* (displayln PROG: prog))
          (if execute?
            (run-vm-prog prog (@" REGS " (root-env: gtx)))
            prog))))))
;----------------------------------------------------------------------------

(define T-env
  (lambda (code expected root-env)
    (set! code (DI! code [code]))
;    (when (nil? env) (set! env [{} []]))
    (let ((r (bukalisp-compile code root-env #t)))
;      (displayln ROOT_ENV: (pp-str root-env))
;      (pp-str root-env)
      (if (eqv? (write-str r) (write-str expected))
        (displayln (str "OK - " code))
        (error (str "Test failed: " code ", returned: " r " != " expected))))))

(define T
  (lambda (code expected)
    (T-env code expected (spawn-root-env))))
;----------------------------------------------------------------------------

;; TODO
;; Test eval
;(T '(eval 1)                    1)
;(T '(eval '(+ 1 2))             3)
;(T '(eval '(eval '(+ 1 2)))     3)
;(T '(eval '(eval '(+ 1 2)))     3)
;(T '(let ((env (interaction-environment)))
;      (eval '(define x 12) env)
;      (eval 'x env))
;   12)
;(T '(let ((env (interaction-environment)))
;      (eval '(define x 12) env)
;      (eval '(set! x (* x 2)) env)
;      (eval 'x env))
;   24)

;----------------------------------------------------------------------------

;(PUSH-DEBUG)
;(error XXX:)

;(T '(begin
;  (define x 0)
;  (for (i 1 100000000)
;    (set! x (+ x 1))))
;   100000000)
;;(error o:)
(T '(begin
  (define x 0)
  (define (inc a) (set! x (+ x a)))
  (for (i 1 10000000)
    (inc 1)))
   10000000)
;;
;;(error F:)
(T '(begin
      (define x 10000000)
      (let ((inco (lambda (a) (set! x (+ x a)))))
        (while (> x 0)
               (inco -1)))) 0)
(T '(begin
      (define x 10000000)
      (while (> x 0)
             (set! x (- x 1)))) 0)
(T '(let ((x 10000000))
      (while (> x 0)
             (set! x (- x 1)))) 0)
(error X:)
;----------------------------------------------------------------------------

; Test basic (lambda ...) and (let ...)
(T '((lambda (y)
       (let ((x 10))
         (+ x y)))
     13)
   23)

(T '(begin
      (define x 5)
      (+ 1 2 x))
   8)

(T '((lambda (x) (+ x 10)) 11)
   21)

(T '((lambda ()
       (define z 10))) 10)

; Test more basic things:
(T '(+ 1 2 3 4 5 6) 21)

(T '(begin
      (+ 1 123)
      (+ 1 345)
      (+ 1 567))
   568)

(T '(begin 123) 123)
(T '(+ 123)     123)
(T '(+ 1 123)   124)
(T '(begin
      (define x 12)
      (define y 34)
      (+ x y))
   46)
(T '(begin
      (define x 12)
      (define y 34)
      (+ x y))
   46)
(T '(begin
      (define x 12)
      (set! x (+ 14.5 x)))
   26.5)
(T '(begin
      (define x +)
      (set! x (x 1.5 1)))
   2.5)

(T '(* 2 3 4)          24)

(T '(> (atom-id []) 0) #true)

; Test var-args:
(T '((lambda (. x) x) 1 2 3) '(1 2 3))

(T '((lambda (. x) x))              [])
(T '((lambda (. x) x) 1 2 3)        [1 2 3])
(T '((lambda (a . x) [a x]) 1 2 3)  [1 [2 3]])
(T '((lambda (a . x) [a x]) 1)      [1 []])
(T '((lambda (a . x) [a x]) nil)    [nil []])
(T '(begin
      (define (x a . v) [a v])
      (x 1 2 3))
   [1 [2 3]])

; Test upvalues and closures
(T '((lambda (x) x) 5)
   5)

(T '((lambda (x y)
       (+ 1 ((lambda () x))))
     5 nil)
   6)

(T '((lambda (x)
       ((lambda (y) (+ x y))
        10))
     5)
   15)

(T '(begin (define x 0)
           (define (o a)
             (set! x (+ x a)))
           (for (i 1 1000000)
             (o 1)))
   1000000)

(T '((((let ((x 10))
         (lambda (y)
           (lambda (j)
             (let ((v (+ y j x)))
               (lambda ()
                 (+
                   ((lambda () (+ v x)))
                   v
                   x
                   j
                   y)))))) 1) 2))
   49)

; Test weird (define ...)s:
(T '(let ((x (begin
               (define y 20)
               (+ 10 y))))
      (define o 20)
      (+ y x o))
   70)
(T '(let ((x 1))
      (define o 10)
      (+ o x))
   11)

; Test (for ...), upvalues and closures:
(T '(begin (define x 0)
           (define (o a)
             (set! x (+ x a)))
           (for (i 1 1000000)
             (o 1)))
   1000000)

(T '(let ((x 0))
      (define (o a)
        (set! x (+ x a)))
      (for (i 1 1000000)
        (o 1)))
   1000000)

(T '(let ((x 0)
          (y 0))
      (define (o a fn-i)
        (set! x (+ x a))
        (set! y (+ y (fn-i))))
      (for (i 1 100000)
        (o 1 (lambda () i)))
      [x y])
   [100000 5000050000])

(T '(let ((x 0)
          (y 0))
      (define (o a fn-i)
        (set! x (+ x a))
        (set! y (+ y (fn-i))))
      (for (i 1 100000)
        (let ((j i))
          (o 1 (lambda () j))))
      [x y])
   [100000 5000050000])

; Test basic variable handling:
(T '(begin (define y 30) y) 30)
(T '(begin (define x 12)
           (define y 30)
           (set! y 10)
           y) 10)

; Test data loading:
(T 'a: a:)
(T '[1 2 3] '(1 2 3))
(T '{x: 12} {x: 12})
(T ''{x: 12} {x: 12})
(T '{x: (+ 6 2)} {x: 8})
(T ''(1 2 3) '(1 2 3))
(T ''(eq? 1 2) '(eq? 1 2))

; Test arithmetics:
(T '(+ 1 2 3) 6)
(T '(+ 1.2 2 3) 6.2)
(T '(* 1.2 2 3) 7.2)
(T '(/ 8 2 2) 2)
(T '(/ 5 2) 2)
(T '(- 10.5 1.3 2.2) 7)
(T '(< 1 2) #true)
(T '(> 1 2) #false)
(T '(<= 1 2) #true)
(T '(<= 1 2) #true)
(T '(<= 2 2) #true)
(T '(<= 2.1 2) #false)
(T '(>= 2.1 2) #true)

; Test procedures:
(T '(eqv? #t #t) #true)
(T '(eqv? #f #f) #true)
(T '(eqv? #t #f) #false)

(T '(eqv? a: a:) #true)
(T '(eqv? a: b:) #false)

(T '(eqv? 'a 'a) #true)
(T '(eqv? 'a 'b) #false)

(T '(eqv? 2 (/ 4 2)) #true)
(T '(eqv? 2 (/ 4.0 2.0)) #false)
(T '(eqv? 2.0 (/ 4.0 2.0)) #true)

(T '(eqv? [] []) #false)
(T '(eqv? {} {}) #false)
(T '(eqv? { x: 11 } { x: 10 }) #false)
(T '(eqv? 2 (/ 5 2)) #true)
(T '(eqv? 2 (/ 5.0 2)) #false)
(T '(eqv? #f 0) #false)
(T '(eqv? #f []) #false)
(T '(eqv? 2.0 2) #false)

(T '(eqv? + (let ((y +)) y)) #true)
(T '(eqv? + (let ((o +)) (let ((y +)) y o))) #true)
(T '(let ((m { x: 11 }) (l #f)) (set! l m) (eqv? m l)) #true)

(T '(not #t) #false)
(T '(not 1) #false)
(T '(not '()) #false)
(T '(not #f) #true)

; Testing predicates
(T '(symbol? 'a) #true)
(T '(symbol? a:) #false)
(T '(symbol? 1) #false)

(T '(keyword? a:) #true)
(T '(keyword? 'a) #false)
(T '(keyword? 1) #false)

(T '(nil? 1) #false)
(T '(nil? 0) #false)
(T '(nil? []) #false)
(T '(nil? nil) #true)

(T '(exact? nil) #false)
(T '(exact? 123) #true)
(T '(exact? 1.0) #false)

(T '(inexact? nil) #false)
(T '(inexact? 123) #false)
(T '(inexact? 1.0) #true)

(T '(number? 'x)            #false)
(T '(number? x:)            #false)
(T '(number? [1 2 3])       #false)
(T '(number? { a: 1 b: 2 }) #false)
(T '(number? [])            #false)
(T '(number? {})            #false)
(T '(number? #true)         #false)
(T '(number? #false)        #false)
(T '(number? nil)           #false)
(T '(number? 1)             #true)
(T '(number? "abc")         #false)

(T '(string? 1) #false)
(T '(string? a:) #false)
(T '(string? 'a) #false)
(T '(string? "foo") #true)
(T '(boolean? "foo") #false)
(T '(boolean? #t) #true)
(T '(boolean? #f) #true)
(T '(boolean? nil) #false)

(T '(list? nil) #false)
(T '(list? []) #true)
(T '(list? '()) #true)
(T '(list? string?) #false)
(T '(list? {}) #false)

(T '(map? {}) #true)
(T '(map? '()) #false)
(T '(map? []) #false)
(T '(map? nil) #false)

(T '(procedure? string?) #true)
(T '(procedure? (lambda (x) x)) #true)
;(T '(procedure? if) #false)
(T '(procedure? '()) #false)

(T '(symbol? 'x)             '#true)
(T '(symbol? x:)             '#false)
(T '(symbol? [1 2 3])        '#false)
(T '(symbol? { a: 1 b: 2 })  '#false)
(T '(symbol? [])             '#false)
(T '(symbol? {})             '#false)
(T '(symbol? #true)          '#false)
(T '(symbol? #false)         '#false)
(T '(symbol? nil)            '#false)
(T '(symbol? 1)              '#false)
(T '(symbol? "abc")          '#false)

(T '(keyword? 'x)            '#false)
(T '(keyword? x:)            '#true)
(T '(keyword? [1 2 3])       '#false)
(T '(keyword? { a: 1 b: 2 }) '#false)
(T '(keyword? {})            '#false)
(T '(keyword? [])            '#false)
(T '(keyword? #true)         '#false)
(T '(keyword? #false)        '#false)
(T '(keyword? nil)           '#false)
(T '(keyword? 1)             '#false)
(T '(keyword? "abc")         '#false)

(T '(list? 'x)               '#false)
(T '(list? x:)               '#false)
(T '(list? [1 2 3])          '#true)
(T '(list? { a: 1 b: 2 })    '#false)
(T '(list? [])               '#true)
(T '(list? {})               '#false)
(T '(list? #true)            '#false)
(T '(list? #false)           '#false)
(T '(list? nil)              '#false)
(T '(list? 1)                '#false)
(T '(list? "abc")            '#false)

(T '(map? 'x)                '#false)
(T '(map? x:)                '#false)
(T '(map? [1 2 3])           '#false)
(T '(map? { a: 1 b: 2 })     '#true)
(T '(map? [])                '#false)
(T '(map? {})                '#true)
(T '(map? #true)             '#false)
(T '(map? #false)            '#false)
(T '(map? nil)               '#false)
(T '(map? 1)                 '#false)
(T '(map? "abc")             '#false)

(T '(string? 'x)             '#false)
(T '(string? x:)             '#false)
(T '(string? [1 2 3])        '#false)
(T '(string? { a: 1 b: 2 })  '#false)
(T '(string? [])             '#false)
(T '(string? {})             '#false)
(T '(string? #true)          '#false)
(T '(string? #false)         '#false)
(T '(string? nil)            '#false)
(T '(string? 1)              '#false)
(T '(string? "abc")          '#true)

(T '(boolean? 'x)            '#false)
(T '(boolean? x:)            '#false)
(T '(boolean? [1 2 3])       '#false)
(T '(boolean? { a: 1 b: 2 }) '#false)
(T '(boolean? [])            '#false)
(T '(boolean? {})            '#false)
(T '(boolean? #true)         '#true)
(T '(boolean? #false)        '#true)
(T '(boolean? nil)           '#false)
(T '(boolean? 1)             '#false)
(T '(boolean? "abc")         '#false)

(T '(nil? 'x)                '#false)
(T '(nil? x:)                '#false)
(T '(nil? [1 2 3])           '#false)
(T '(nil? { a: 1 b: 2 })     '#false)
(T '(nil? [])                '#false)
(T '(nil? {})                '#false)
(T '(nil? #true)             '#false)
(T '(nil? #false)            '#false)
(T '(nil? nil)               '#true)
(T '(nil? 1)                 '#false)
(T '(nil? "abc")             '#false)

; Test (type ...):
(T '(let ((m { 'nil 1234 }))
      (@(type nil) m))
   nil)

(T '(let ((m { (type nil) 1234 }))
      (@(type nil) m))
   1234)

(T '(type []) 'list)
(T '(type [1 2 3]) 'list)
(T '(type '()) 'list)
(T '(type '(1 2 3)) 'list)
(T '(type {}) 'map)
(T '(type map?) 'procedure)
(T '(type (lambda () nil)) 'procedure)
(T '(type 1) 'exact)
(T '(type 1.0) 'inexact)
(T '(type nil) 'nil)
(T '(type #t) 'boolean)
(T '(type #f) 'boolean)
(T '(type 'f) 'symbol)
(T '(type f:) 'keyword)
(T '(type "f") 'string)

; Test 'length' primitive
(T '(length [1 2 3]) 3)
(T '(length []) 0)
(T '(length '()) 0)
(T '(length {}) 0)
(T '(length {x: 12}) 1)
(T '(length {y: 324 x: 12}) 2)
(T '(length (let ((l [])) (@!9 l l))) 10)

(T '(length (list 1 2 3)) 3)
(T '(length (list)) 0)
(T '(if (>  (length (list 1 2 3)) 3) "yes" "no") "no")
(T '(if (>= (length (list 1 2 3)) 3) "yes" "no") "yes")
(T '(begin (let ((c length)) (c [1 2 3 (define x 20)]))) 4)
(T '(begin (length [1 2 3 (define x 20)]) x) 20)
(T '(begin [1 2 3 (define x 20)] x) 20)

; Test other primitives:
(T '(first '(a b c)) 'a)
(T '(first '()) 'nil)
(T '(first [3]) '3)
(T '(last [1 2 3]) '3)
(T '(last [3]) '3)
(T '(last []) 'nil)
(T '(take [x: y: 12 3 4] 2) '(x: y:))
(T '(take [1] 2) '(1))
(T '(take [1 2] 2) '(1 2))
(T '(take [] 2) '())
(T '(drop [1 2 3] 2) '(3))
(T '(drop [1 2 3] 4) '())
(T '(drop [1 2 3] 3) '())
(T '(drop [] 3) '())
(T '(drop [1 2 3] 0) '(1 2 3))
(T '(drop [1 2 3] 1) '(2 3))
(T '(append [1 2 3] 1 a: { x: 12 } [5 5 5]) '(1 2 3 1 a: x: 12 5 5 5))
(T '(append [1 2 3]) '(1 2 3))

; Test system primitives:
(T '(sys-slurp-file "foo.txt") "xxx\n")

; Test let TODO: Moar!
(T '(let ((x 10)) x) 10)

; Test some assignment stuff:
(T '(begin
      (define x 0)
      (set! x (+ x 1 2 3 4 5))) 15)
(T '(begin
      (define x 0)
      (set! x (not x)))
   #f)

; Testing big lambda applications:
(T '((lambda (x)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)
       ((lambda (y) 9) 10)) 9)
   9)

(T '((lambda (x)   (+ x 1)) 1.5) 2.5)
(T '((lambda (x y) (+ (* x y) 1)) 1.5 4) 7.0)
(T '((lambda (x y _ _ _) (+ (* x y) 1)) 1.5 4 e: r: g:) 7.0)
(T '((lambda (x)
       ((lambda (y) (+ x y))
        10))
     5)
   15)
(T '((lambda (x)
       ((lambda (y) (+ 1 0 3 30 30 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10)
       ((lambda (y) (+ 1 x y)) 10))
     5) 16)

(T '(let ((x [])
          (c 10))
      (set! c (lambda (o) (push! x o)))
      (c 1)
      (c 2)
      x)
   [1 2])

; Test recursive calling:
(T '(let ((x [])
          (c 11))
      (set! c
        (lambda (o)
          (push! x o)
          (when (eqv? o 0)
            (return 11))
          (c (- o 1))))
      (c 2)
      x)
   [2 1 0])

; Test define
(T '(begin (define x 10) x)     10)
(T '(begin (define (x) 10) (x)) 10)
(T '(begin
      (define (x b c)
        (+ (* b c) 10))
      (x 2.5 10))
   35)
(T '(begin (define x 10) (define x 20) x) 20)
(T '(begin (define x 10) (define y 20) (define x 21) [x y]) '(21 20))
(T '(begin (define x 10) (define y 20) (define x y) x) 20)
(T '(begin (define if 10) if) 10)


; Test varargs
(T '((lambda (. x) x))              [])
(T '((lambda (. x) x) 1 2 3)        [1 2 3])
(T '((lambda (a . x) [a x]) 1 2 3)  [1 [2 3]])
(T '((lambda (a . x) [a x]) 1)      [1 []])
(T '((lambda (a . x) [a x]) nil)    [nil []])
(T '(begin
      (define (x a . v) [a v])
      (x 1 2 3))
   [1 [2 3]])

(T '(begin
      (define (x a . v)
        (define z v)
        [a z])
      (x 1 2 3))
   [1 [2 3]])

; Test using a known environemt which is mutatable:
(let ((my-env (spawn-root-env)))
  (T-env '(begin (define x 13.3)) 13.3 my-env)
  (T-env '(begin x)               13.3 my-env)
  (T-env '(define y x)            13.3 my-env)
  (T-env '(+ x y)                 26.6 my-env))

; test externally given environment executed inside VM:
(let ((my-env (spawn-root-env)))
  (set-root-env-var my-env 'foo 123)
;  (displayln (pp-str my-env))
  (T-env '(begin foo) 123 my-env)
  (T-env '(begin
            (define k 10)
            ((lambda () foo)))
         123
         my-env))

; test recursive calling into VM:
(let ((my-env (spawn-root-env))
      (func (bukalisp-compile
              ['(displayln foo-out: (+ 10 20))]
              my-env
              #f)))
  (set-root-env-var my-env 'xxx func)
  (T-env '(begin
            (define k 10)
            ((lambda ()
               (run-vm-prog xxx [])))
            (+ 12.345 k))
         22.345
         my-env))

; Test conditionals:
(T '(when   #t 10) 10)
(T '(when   #f 10) nil)
(T '(unless #t 10) nil)
(T '(unless #f 10) 10)
(T '(begin
      (define x 10)
      (when (> 0 -1)
        (let ((y 22))
          (set! x (* 1.23 x y))))
      x)
   270.6)
(T '(begin
      (define x 10)
      (when (> 0 1)
        (let ((y 22))
          (set! x (* 1.23 x y))))
      x)
   10)

(T '(if #t 10 20) 10)
(T '(if #t 10)    10)
(T '(if #f 10 20) 20)
(T '(if #f 10)    nil)

(T '(begin
      (define x 10)
      (if (> 0 -1)
        (let ((y 22))
          (set! x (* 1.27 x y)))
        (let ((y 22))
          (set! x (* 1.23 x y))))
      x)
   279.4)

(T '(begin
      (define x 10)
      (if (> 0 1)
        (let ((y 22))
          (set! x (* 1.27 x y)))
        (let ((y 22))
          (set! x (* 1.23 x y))))
      x)
   270.6)

(T '(let ((aid  (atom-id (type nil)))
          (aid2 (atom-id (type nil)))
          (aid3 (atom-id (type nil))))
      [(eqv? aid aid2) (eqv? aid aid3)])
   '(#t #t))


(T '(begin (define x 0)
           (define (o a)
             (set! x (+ x a)))
           (for (i 1 1000000)
             (o 1)))
   1000000)

(T '(begin (define x 0)
;           (define (o a)
;             (set! x (+ x a)))
           (for (i 1 10000000)
             (set! x (+ x 1))))
   10000000)

(T '(begin (define x 0)
           (for (i 0 -100 -1)
             (set! x (+ x i)))
           x)
   -5050)

(T '(begin
      (define x 1)
      (for (i 1 0) (set! x 20) i)
      x)
   1)

(T '(begin
      (define x 1)
      (for (i 1 1) (set! x (+ i 20)) i)
      x)
   21)

(T '(begin
      (define x 1)
      (for (i 1 2) (set! x (+ i 20)) i)
      x)
   22)

; Test binary ops that are (sometimes) optimized by the compiler
; to be statically compiled down to VM OPs:
(T '(+ 1 2 3) 6)
(T '(let ((x +)) (x 1 2 3)) 6)

(T '(+ 2 3) 5)
(T '(let ((x +)) (x 2 3)) 5)

(T '(- 10 2 3) 5)
(T '(let ((x -)) (x 10 2 3)) 5)

(T '(- 10 2) 8)
(T '(let ((x -)) (x 10 2)) 8)

(T '(- 10) -10)
(T '(let ((x -)) (x 10)) -10)

(T '(= 10 10) #t)
(T '(= 10 9) #f)
(T '(let ((x =)) (x 10 10)) #t)
(T '(let ((x =)) (x 10 9)) #f)

(T '(= 10 10 10) #t)
(T '(= 10 10 9) #f)
(T '(let ((x =)) (x 10 10 10)) #t)
(T '(let ((x =)) (x 10 10 9)) #f)


(T '(< 10 11) #t)
(T '(< 10 10) #f)
(T '(< 10 11 12) #t)
(T '(< 10 11 11) #f)
(T '(let ((x <)) (x 10 11 12)) #t)
(T '(let ((x <)) (x 10 11 11)) #f)

(T '(> 11 10) #t)
(T '(> 11 11) #f)
(T '(> 12 11 10) #t)
(T '(> 12 11 11) #f)
(T '(let ((x >)) (x 12 11 10)) #t)
(T '(let ((x >)) (x 12 11 11)) #f)

(T '(>= 11 10) #t)
(T '(>= 11 12) #f)
(T '(>= 12 11 10) #t)
(T '(>= 12 11 12) #f)
(T '(let ((x >=)) (x 12 11 10)) #t)
(T '(let ((x >=)) (x 12 11 12)) #f)

(T '(<= 10 11) #t)
(T '(<= 11 11) #t)
(T '(<= 10 9) #f)
(T '(<= 11 11 12) #t)
(T '(<= 11 11 9) #f)
(T '(let ((x <=)) (x 11 11 12)) #t)
(T '(let ((x <=)) (x 11 11 9)) #f)

; Test accessor operations like @, $, $! and @!
(T ''@ '@)
(T ''@! '@!)

(T '(@0 [22.2 22.4 45]) 22.2)
(T '(let ((at @)) (at 0 [22.2 22.4 45])) 22.2)
(T '(let ((x [])) (@!2 x 10) x) [nil nil 10])
(T '(let ((x [])
          (at-set! @!))
      (at-set! 2 x 10) x)
   [nil nil 10])

(T '(@x: {x: 22.2}) 22.2)
(T '(let ((at @)) (at x: {x: 22.2})) 22.2)
(T '(let ((x {})) (@!x: x 10) x) {x: 10})
(T '(let ((x {})
          (at-set! @!))
      (at-set! x: x 10) x)
   {x: 10})

(T '(let ((x 2) (v [1 2 3])) (@x v)) 3)

(T '(@'x {'x 10}) 10)
(T '(let ((m {'x 10})) (@!'x m 12) m) {'x 12})

; Test include
(T '(begin
      (include "..\\bukalisplib\\test-compiler.bkl")
      test-include-ok)
   1)

; Test meta-infos:
(T '(let ((v []))
      (bkl-set-meta v 2 42)
      (bkl-get-meta v))
   '(nil nil 42))

; Test macros:
(T '(begin
      (define x 10)
      (define m nil)
      (let ()
       (define-macro (x a b)
         ['quote [a b a b]])
       (set! m (x 9 11)))
      [m x])
   [[9 11 9 11] 10])

; Test $define!
(T '(let ((o {x: 0}))
      ($define! o (foo) 9)
      ((@'foo o)))
   9)
(T '(let ((o {x: 0}))
      ($define! o (foo) 9)
      [((@'foo o))])
   [9])
(T '(let ((o {x: 0}))
      ($define! o (foo a b c)
        9
        (@!x: o (+ 1 (x: o)))
        (* a (+ (x: o)
                b
                (* 2 c))))
      [((@'foo o) 1 2 3)
       ((@'foo o) 4 5 6)
       ((@'foo o) 8 8 8)
       ((@'foo o) 9 9 9)])
   [9 76 216 279])

; Test return:
(T '(begin (define x 11) (set! x 32) (return x)) 32)
(T '(begin (define x 11)
           (set! x (return x))
           (return x)) 11)
(T '(begin (define g 10)
           ((lambda ()
              (set! g 33)
              (return nil)
              (set! g 45)))
           g)
   33)
(T '(begin (define g 10)
           ((lambda ()
              (set! g 33)
              (return g)
              (set! g 45))))
   33)
(T '(return 32) 32)
(T '{a: 10 x: (return 20)} 20)

; Test predicates:
(T '(list? (list))                  #true)
(T '(let ((x list?)) (x (list)))    #true)
(T '(list? { a: 1 })                #false)
(T '(let ((x list?)) (x { a: 1 }))  #false)

(T '(empty? (list))                 #true)
(T '(empty? (list 1))               #false)
(T '(empty? {})                     #true)
(T '(empty? {a: 1})                 #false)
(T '(let ((x empty?)) (x (list)))   #true)
(T '(let ((x empty?)) (x (list 1))) #false)
(T '(let ((x empty?)) (x {}))       #true)
(T '(let ((x empty?)) (x {a: 1}))   #false)

; Test (size)
(T '(size nil)      0)
(T '(size [])       0)
(T '(size {})       0)
(T '(size {a: 1})   2)
(T '(size [1])      1)
(T '(size [[]])     1)
(T '(size fooo:)    4)
(T '(size "fooo")   4)
(T '(size 'fooo)    4)
(T '(size [1 2 3 4 [5 6 7 8] 9]) 10)
(T '(size [1 2 3 4 {a: 5 b: 6 c: 7 d: 8} 9]) 14)

; Test return anywhere:
(T '(let ((j (return (+ 9 10)))) nil) 19) ; XXX: Should let be allowed to be empty?

(T '{ b: 20 a: (return 9) x: 22 }
   9)
(T '(list? (return 10)) 10)
(T '(empty? (return 11)) 11)
;(T '(define-global ff (return 12)) 12)
(T '(define ff2 (return 12)) 12)
(T '(begin
      (define ff2 12)
      (set! ff2 (return 13)))
   13)
(T '((return 14) 22) 14)
(T '(begin
      (define x 2)
      ((lambda () 2)
       ((lambda ()
          (set! x 16)))
       (return x)))
   16)
(T '(begin
      (define x 1)
      (+ ((lambda ()
            (set! x 15)))
         (return x)))
   15)
(T '(begin
       (define x 1)
       (define y 2)
       (+
         ((lambda () (set! y 16)))
         (+ ((lambda () (set! x 15)))
            (return (+ x y)))))
   31)
(T '(begin
      (let ((a 10) (b 20)) b)
      (let ((c 30))
        (let ((k 32)
              (j (return (+ k 10)))) nil))
      44)
   42)
(T '(let ((x 11))
      (let ((if (= (set! x 43) (return x)))) 12)
      x)
   43)
(T '(if #t (return 44)) 44)
(T '(if #f 10 (return 45)) 45)
;(T '(begin
;      (define X 10)
;      (. (set! X 47) (return X)))
;   47)

; Test quote
(T ''(+ 1 2) '(+ 1 2))
(T ''((3 4)) '((3 4)))
(T ''(+ 1 (+ 2 3)) '(+ 1 (+ 2 3)))
(T '   '     ( +     1 (+  2 3 )      ) '(+ 1 (+ 2 3)))
(T ''(* 1 2) '(* 1 2))
(T ''(** 1 2) '(** 1 2))
(T ''(1 2 3) '(1 2 3))
(T '''1 '(quote 1))
(T '''(1 2 3) '(quote (1 2 3)))
(T '(quote 7) '7)
(T ''7 '7)
(T '(quote (1 2 3)) '(1 2 3))
(T ''(1 2 3) '(1 2 3))
(T '(quote (1 2 (3 4))) '(1 2 (3 4)))
(T ''(1 2 (3 4)) '(1 2 (3 4)))
(T '(quote (10)) '(10))

; Test apply
(T '(apply + 1 2 3 []) '6)
(T '(apply + 1 2 3 (list)) '6)
(T '(apply + 1 (list 2 3)) '6)
(T '(apply - 0 (list 1)) '-1)
(T '(apply - (list 0 1)) '-1)
(T '(apply str-join "," (list X: Y:)) '"X,Y")

; Test bkl-doc documentation
(T '(begin
      (bkl-set-doc! xxx-test-bkl: "foobar-xxx-yyy")
      (?doc ?foobar-x:))
   ["foobar-xxx-yyy"]);
(T '(begin
      (bkl-set-doc! xxx-test-bkl: "foobar-xxx-yyy")
      (?doc xxx-test:))
   ["foobar-xxx-yyy"]);
(T '(begin
      (bkl-set-doc! xxx-test-bkl: "foobar-xxx-yyy")
      (?doc xxx-yyy:))
   []);
(T '(begin
      (bkl-set-doc! xxx-test-bkl: "foobar-xxx-yyy")
      (?doc *-yyy:))
   ["foobar-xxx-yyy"]);

; Test while
(T '(let ((i 0) (j 1.0))
      (while (< i 3)
             (set! j (* j 2))
             (set! i (+ i 1)))
      j)
   8)

; Test do-each
(T '(let ((o []))
      (do-each (x [1 2 3])
        (push! o x))
      o)
   [1 2 3])

(T '(let ((o []))
      (do-each (x [])
        (push! o x))
      o)
   [])

(T '(let ((sum 0))
      (do-each (v {a: 1 b: 2 c: 3 e: 5 f: 11})
        (set! sum (+ sum v)))
      sum)
   22)

(T '(let ((o []))
      (do-each (k v [5 6 7])
        (push! o k)
        (push! o v))
      o)
   [0 5 1 6 2 7])

(T '(let ((o []))
      (do-each (k v {a: 12})
        (push! o k)
        (push! o v))
      o)
   [a: 12])

(T '(let ((o []))
      (do-each (k v {})
        (push! o k)
        (push! o v))
      o)
   [])

; Testing some shallow copy operations and assignments
(T '(let ((v [1 2 3])
          (v_ (list-copy v)))
      [(eqv? v v) (eqv? v v_) v_])
   [#t #f [1 2 3]])

(T '(let ((m {a: 10})
          (m_ (map-copy m)))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f {a: 10}])

(T '(let ((m {a: 10})
          (m_ (assign m [a: 20])))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f {a: 20}])

(T '(let ((m {a: 10})
          (m_ (assign m {a: 20})))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f {a: 20}])

(T '(let ((m [1 2 3 4])
          (m_ (assign m {0 10 2 30})))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f [10 2 30 4]])

(T '(let ((m [1 2 3 4])
          (m_ (assign m [0 10 2 30])))
      [(eqv? m m) (eqv? m m_) m_])
   [#t #f [10 2 30 4]])

