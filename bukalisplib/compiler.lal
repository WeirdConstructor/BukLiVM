(define primitive-table
'{<= 6 symbol? 11 + 0 * 1 / 2 - 3 < 4 first 37 exact? 14 list 8 append 40 keyword? 12 > 5 >= 7 eqv? 9 map? 19 not 10 nil? 13 inexact? 15 string? 16 boolean? 17 write-str 41 @! 22 list? 18 pop! 26 procedure? 20 @ 21 type 23 display 30 length 24 push! 25 make-vm-prog 27 str-join 35 run-vm-prog 28 error 29 newline 31 eval 42 displayln 32 atom-id 33 str 34 last 36 take 38 drop 39 invoke-compiler 43}
)
;----------------------------------------------------------------------------

(define make-code-pad-object
  (lambda (out-pad)
    (let ((self { code: [] debug-info: {} }))
      (define push-op
        (lambda (op-desc)
          (@!op-desc
           ($debug-info: self)
           ($debug-pos: out-pad))
          (push! ($code: self) op-desc)))

      ($define! self (append-code-pad code-pad)
        (let ((code ($code: self)))
          (do-each (k v ($debug-info: code-pad))
            (@! k ($debug-info: self) v))
          (do-each (op ($code: code-pad))
            (push! code op))))

      ($define! self (to-vm-prog-code)
        ($code: self))

      ($define! self (to-vm-prog-debug-info)
        (let ((m {}) (i 0))
          (do-each (op-desc ($code: self))
            (@!i m (@op-desc ($debug-info: self)))
            (set! i (+ i 1)))
          m))

      ($define! self (op-push-env size)
        (push-op [PUSH_ENV: 0 size]))

      ($define! self (op-pop-env)
        (push-op [POP_ENV: 0 0]))

      ($define! self (op-dump-env-stack)
        (push-op [DUMP_ENV_STACK: 0 0]))

      ($define! self (op-set-return idx)
        (push-op [SET_RETURN: 0 idx]))

      ($define! self (op-return idx)
        (push-op [RETURN: 0 idx]))

      ($define! self (op-mov out-idx in-idx)
        (push-op [MOV: out-idx in-idx]))

      ($define! self (op-mov-from out-idx env-idx in-idx)
        (push-op [MOV_FROM: out-idx env-idx in-idx]))

      ($define! self (op-mov-to out-idx env-idx in-idx)
        (push-op [MOV_TO: out-idx env-idx in-idx]))

      ($define! self (op-load-prim out-idx prim-nr)
        (push-op [LOAD_PRIM: out-idx prim-nr]))

      ($define! self (op-new-vec out-idx len)
        (push-op [NEW_VEC: out-idx len]))

      ($define! self (op-new-map out-idx)
        (push-op [NEW_MAP: out-idx 0]))

      ($define! self (op-set-vec vec-idx idx src-idx)
        (push-op [SET_VEC: vec-idx idx src-idx]))

      ($define! self (op-cset-vec vec-idx idx src-idx)
        (push-op [CSET_VEC: vec-idx idx src-idx]))

      ($define! self (op-call out-idx func-idx argvec-idx)
        (push-op [CALL: out-idx func-idx argvec-idx]))

      ($define! self (op-new-closure out-idx in-idx)
        (push-op [NEW_CLOSURE: out-idx in-idx]))

      ($define! self (op-pack-va out-idx env-pos-idx)
        (push-op [PACK_VA: out-idx env-pos-idx]))

      ($define! self (op-load static out-idx)
        ; TODO: optimize static data loading by storing their
        ;       positions in a map
        (let ((idx (.add-static-data out-pad static)))
          (push-op [LOAD_STATIC: out-idx idx]))))))
;----------------------------------------------------------------------------

(define make-static-data-pad
 (lambda (debug-info)
   (let ((self { pad: []
                 stack: []
                 debug-pos: nil
                 debug-info: debug-info }))

     ($define! self (push-static-data-frame)
       (push! ($stack: self) ($pad: self))
       ($!pad: self []))

     ($define! self (pop-static-data-frame)
       ($!pad: self (pop! ($stack: self))))

     ($define! self (set-debug-pos atom)
       (let ((info (@(atom-id atom) debug-info)))
         (unless (nil? info)
           ($!debug-pos: self info))))

     ($define! self (add-static-data data)
       (push! ($pad: self) data)
       (- (length ($pad: self)) 1))

     ($define! self (make-code-pad)
        (make-code-pad-object self))

     ($define! self (to-vm-prog code-pad)
        (make-vm-prog [($pad:  self)
                       (.to-vm-prog-code       code-pad)
                       (.to-vm-prog-debug-info code-pad)]))

     self)))
;----------------------------------------------------------------------------

(define dispatch
 (lambda (key m arg)
   (if (eqv? (@key m) nil)
     (error "unhandled dispatch, for key" key m))

   ((@key m) arg)))
;----------------------------------------------------------------------------

(define type-dispatch
 (lambda (atom m arg arg2 arg3)
   (if (eqv? (@(type atom) m) nil)
     (error (str "unhandled dispatch, for type " (type atom)) atom m))

   ((@(type atom) m) atom arg arg2 arg3)))
;----------------------------------------------------------------------------

(define compile-quote-dispatch-map
 { (type nil) (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'exact     (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'inexact   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'keyword   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'boolean   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'string    (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'symbol    (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))

   'map       (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (.op-new-map code-pad out-idx)
                (let ((k-idx (.new-tmp-pos self))
                      (v-idx (.new-tmp-pos self)))
                  (do-each (k v atom)
                   (.compile-quote self k code-pad k-idx)
                   (.compile-quote self v code-pad v-idx)
                   (.op-cset-vec code-pad out-idx k-idx v-idx))
                  (.recycle-tmp-pos self k-idx)
                  (.recycle-tmp-pos self v-idx)))

   'list      (lambda (atom self code-pad out-idx)
                (let ((tmp-idx (.new-tmp-pos self))
                      (i 0))
                  (.op-new-vec code-pad out-idx (length atom))
                  (do-each (a atom)
                    (.set-debug-pos self atom)
                    (.compile-quote self a code-pad tmp-idx)
                    (.op-cset-vec code-pad out-idx i tmp-idx)
                    (set! i (+ i 1)))
                  (.recycle-tmp-pos self tmp-idx)))})
;----------------------------------------------------------------------------

(define compile-expr-dispatch-map
 { (type nil) (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'exact     (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'inexact   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'keyword   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'boolean   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'string    (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))

   'map       (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (.op-new-map code-pad out-idx)
                (let ((k-idx (.new-tmp-pos self))
                      (v-idx (.new-tmp-pos self)))
                  (do-each (k v atom)
                   (.compile self k code-pad k-idx)
                   (.compile self v code-pad v-idx)
                   (.op-cset-vec code-pad out-idx k-idx v-idx))
                  (.recycle-tmp-pos self k-idx)
                  (.recycle-tmp-pos self v-idx)))

   'symbol    (lambda (atom self code-pad out-idx)
                (let ((var (.lookup self atom)))
                  (when (nil? var)
                    (.error self "Undefined variable" atom))
                  (case (@0 (@1 var))
                    ((var:)
                     (let ((var-idx (@1 (@1 var))))
                       (if (> (@0 var) 0)
                         (.op-mov-from code-pad out-idx (@0 var) var-idx)
                         (.op-mov      code-pad out-idx var-idx))))
                    ((prim:)
                     (.op-load-prim code-pad out-idx (@1 (@1 var))))
                    ((syntax:)
                     (let ((prim-nr (@2 (@1 var))))
                       (when (nil? prim-nr)
                         (.error self "Syntax is not translatable to a primitive" atom))
                       (.op-load-prim code-pad out-idx prim-nr)))
                    (else
                      (.error self "Not a value binding variable" atom)))))

   'list      (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (case (type (@0 atom))
                  ((symbol)
                   (let ((var (.lookup self (@0 atom))))
                     (when (nil? var)
                       (.error self "Undefined variable" (@0 atom)))
                     (case (@0 (@1 var))
                       ((prim:)
                        (.compile-func-apply self atom code-pad out-idx))
                       ((syntax:)
                        (if (nil? (@2 (@1 var)))
                          ((@1 (@1 var)) atom self code-pad out-idx)
                          ; TODO: Instead of preferring the primitive,
                          ;       use the compiler func instead here!
                          (.compile-func-apply self atom code-pad out-idx)))
                       ((var:)
                        (.compile-func-apply self atom code-pad out-idx))
                       (else
                         (.error self "Bad variable type" var)))))
                  ((list)
                   (.compile-func-apply self atom code-pad out-idx))
                  (else
                    (.error self "Invalid atom type at start of list" atom))))})
;                (do-each (a atom)
;                  (displayln DO-LIST_ITEM: a)
;                  (.compile-quote self a code-pad out-idx)))})
;----------------------------------------------------------------------------

(define recursive-lookup
  (lambda (env-stack lvl-idx sym)
    (let ((cur-env (@(- (length env-stack)
                        (+ 1 lvl-idx))
                     env-stack))
          (var-type (@sym cur-env))
          (next-lvl-idx (+ 1 lvl-idx)))
      (if (nil? var-type)
        (when (< next-lvl-idx (length env-stack))
          (recursive-lookup env-stack next-lvl-idx sym))
        [lvl-idx var-type]))))
;----------------------------------------------------------------------------

;(define make-prim-syntax
;  (lambda (compiler symbol compiler-func prim-nr)
;    (.define-var compiler symbol [syntax: compiler-func prim-nr])))
;----------------------------------------------------------------------------

(define set-env-syntax
  (lambda (env symbol compiler-func)
    (@!symbol env [syntax: compiler-func])))
;----------------------------------------------------------------------------

(define hook-compiler-methods
  (lambda (self)
    ($!env-stack:     self [])
    ($!env-pos-stack: self [])
    ($!macro-compiler: self [])

    ($define! self (clone-compiler)
      (let ((cpad (make-static-data-pad ($debug-info: self))))
        (hook-compiler-methods cpad)
        (.copy-env-from cpad self)
        cpad))

    ($define! self (copy-env-from other-compiler)
      (.push-env self)
      (do-each (sym var (first ($env-stack: other-compiler)))
        (when (eqv? (@0 var) syntax:) (.define-var self sym var))
        (when (eqv? (@0 var) prim:)   (.define-var self sym var))
        (when (eqv? (@0 var) macro:)  (.define-var self sym var))))

    ($define! self (error msg atom)
      (error (str-join " " "BukaLISP-Compiler Error: " ($debug-pos: self) msg)
             atom))

    ($define! self (new-tmp-pos)
      (let ((env-pos (last ($env-pos-stack: self)))
            (free-tmp-pos-list (@1 env-pos)))
        (if (> (length free-tmp-pos-list) 0)
          (pop! free-tmp-pos-list)
          (let ((new-pos (@0 env-pos)))
            (@!0 env-pos (+ new-pos 1))
            new-pos))))

    ($define! self (new-pos)
      (let ((env-pos (last ($env-pos-stack: self)))
            (new-pos (@0 env-pos)))
        (@!0 env-pos (+ 1 new-pos))
        new-pos))

    ($define! self (recycle-tmp-pos pos)
      (push! (@1 (last ($env-pos-stack: self))) pos))

    ($define! self (define-var sym var-type)
      (let ((cur-env (last ($env-stack: self))))
        (@!sym cur-env var-type)))

    ($define! self (lookup sym)
      (recursive-lookup ($env-stack: self) 0 sym))

    ($define! self (push-env)
      (push! ($env-pos-stack: self) [0 []])
      (push! ($env-stack: self) {}))

    ($define! self (cur-env-size)
      (+ 1 (@0 (last ($env-pos-stack: self)))))

    ($define! self (pop-env)
      (pop! ($env-pos-stack: self))
      (pop! ($env-stack: self)))

    ($define! self (compile-func-apply atom code-pad out-idx)
      ; eval all items (func a b c) into temporary registers
      ; make new vec
      ; set vec from tmp registers
      ; do a CALL with the index of the function and the index of the arg vector
      ; CALL figures out what to do with #<primitive> or #<closure>
      (let ((end-idx    (- (length atom) 1))
            (func-idx   (.new-tmp-pos self))
            (argvec-idx (.new-tmp-pos self))
            (arg-idxes []))
        (.compile self (@0 atom) code-pad func-idx)
        (when (> end-idx 0)
          (for (i 1 end-idx)
            (let ((arg-idx (.new-tmp-pos self)))
              (push! arg-idxes arg-idx)
              (.set-debug-pos self atom)
              (.compile       self (@i atom) code-pad arg-idx))))
        (.op-new-vec code-pad argvec-idx (- (length atom) 1))
        (when (> end-idx 0)
          (for (i 0 (- end-idx 1))
            (.op-cset-vec     code-pad argvec-idx i (@i arg-idxes))
            (.recycle-tmp-pos self (@i arg-idxes))))
        ;       (.op-dump-env-stack code-pad)
        (.op-call         code-pad out-idx func-idx argvec-idx)
        (.recycle-tmp-pos self func-idx)))

    ($define! self (compile-lambda parameters body code-pad out-idx)
      (.push-static-data-frame self)
      (.push-env self)
      (define dot-var  #f)
      (do-each (var parameters)
        (unless (symbol? var)
          (.error self "Can't use non symbol in lambda parameter list" var))
        (if dot-var
          (if (eqv? (type dot-var) 'exact)
            (.error self "After a '.' only one symbol can follow" parameters)
            (.define-var self var [var: (set! dot-var (.new-pos self))]))
          (begin
            (if (eqv? var '.)
              (set! dot-var #t)
              (.define-var self var [var: (.new-pos self)])))))
      (when dot-var
        (unless (eqv? (type dot-var) 'exact)
          (.error self "'.' must follow a symbol" parameters)))
      (let ((ret-val-pos     (.new-tmp-pos self))
            (lambda-code-pad (.make-code-pad self)))
        (when dot-var
          (.op-pack-va lambda-code-pad dot-var dot-var))
        (.compile-block self body lambda-code-pad ret-val-pos)
        (.op-return     lambda-code-pad ret-val-pos)
        (let ((new-prog (.to-vm-prog self lambda-code-pad)))
          (.pop-env               self)
          (.pop-static-data-frame self)
          (.op-load               code-pad new-prog out-idx)
          (.op-new-closure        code-pad out-idx out-idx))))

    ($define! self (compile-block block code-pad out-idx)
      (do-each (expr block)
        (.compile self expr code-pad out-idx)))

    ($define! self (compile atom code-pad out-idx)
      (type-dispatch atom compile-expr-dispatch-map self code-pad out-idx))

    ($define! self (compile-quote atom code-pad out-idx)
      (type-dispatch atom compile-quote-dispatch-map self code-pad out-idx))

    ($define! self (push-root-env root-env)
      (push! ($env-stack: self) (@0 root-env))
      (let ((new-pos (length (@1 root-env))))
        ; reserve space for the return value of top-level expressions:
        (when (eqv? new-pos 0)
          (set! new-pos 1))
        (push! ($env-pos-stack: self) [new-pos []])))

    ($define! self (make-base-env)
      (define new-env {})
      ;    (make-prim-syntax self '+
      ;     (lambda (atom self code-pad out-idx) 0)
      ;     0)

      (do-each (k v primitive-table)
        (@!k new-env [prim: v]))
      ;----------------------------------------------------------------------------

      ;       (unless (< 2 (length atom))
      ;         (.error self "'+' needs 3 arguments" atom))
      ;       (unless (symbol? (@1 atom))
      ;         (.error self "Can only define symbols as variable" atom))
      ;
      ;       (let ((bind-idx (.new-pos self)))
      ;         (.define-var self (@1 atom) [var: bind-idx])
      ;         (.compile self (@2 atom) code-pad bind-idx)
      ;         (.op-mov code-pad out-idx bind-idx))

      (set-env-syntax new-env 'begin
       (lambda (atom self code-pad out-idx)
         (.compile-block self (drop atom 1) code-pad out-idx)))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'lambda
       (lambda (atom self code-pad out-idx)
         (.compile-lambda self (@1 atom) (drop atom 2) code-pad out-idx)))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'let
       (lambda (atom self code-pad out-idx)
         (unless (> (length atom) 1)
           (.error self "'let' needs at least 1 argument (the binding list)" atom))
         (unless (eqv? (type (@1 atom)) 'list)
           (.error self "'let' binding list needs to be a list" atom))
         (let ((env-size 0))
           (do-each (bind-pair (@1 atom))
             (unless (eqv? (type bind-pair) 'list)
               (.error self "'let' binding pair needs to be a list" bind-pair))
             (unless (eqv? (length bind-pair) 2)
               (.error self "'let' binding pair needs exactly 2 elements" bind-pair))
             (unless (eqv? (type (@0 bind-pair)) 'symbol)
               (.error self "'let' binding pair must contain a symbol as first element" bind-pair))
             (set! env-size (+ env-size 1)))
           (.push-env    self)
           (.op-push-env code-pad env-size)
           (let ((transmit-pos (.new-tmp-pos self)))
             (do-each (bind-pair (@1 atom))
               (let ((var-pos (.new-pos self)))
                 (.define-var self (@0 bind-pair) [var: var-pos])
                 (.compile    self (@1 bind-pair) code-pad var-pos)))
             (.compile-block   self (drop atom 2) code-pad transmit-pos)
             (.op-mov-to       code-pad out-idx 1 transmit-pos)
             (.recycle-tmp-pos self transmit-pos)
             (.op-pop-env      code-pad)
             (.pop-env         self)))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'set!
       (lambda (atom self code-pad out-idx)
         (unless (eqv? 3 (length atom))
           (.error self "'set!' needs 2 arguments" atom))
         (unless (symbol? (@1 atom))
           (.error self "Can only use set! on a symbol" atom))
         (let ((var (.lookup self (@1 atom))))
           (when (nil? var)
             (.error self "Undefined variable" atom))
           (.compile self (@2 atom) code-pad out-idx)
           (if (eqv? (@0 (@1 var)) var:)
             (if (> (@0 var) 0)
               (.op-mov-to code-pad (@1 (@1 var)) (@0 var) out-idx)
               (.op-mov    code-pad (@1 (@1 var)) out-idx)))
           (let ((bind-idx (.new-pos self)))
             (.define-var self (@1 atom) [var: bind-idx])
             (.op-mov     code-pad bind-idx out-idx)))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'define
       (lambda (atom self code-pad out-idx)
         (unless (> (length atom) 2)
           (.error self "'define' needs at least 2 arguments" atom))
         (if (symbol? (@1 atom))
           (begin
             (unless (eqv? 3 (length atom))
               (.error self "'define' needs 2 arguments" atom))
             (let ((bind-idx (.new-pos self)))
               (.define-var self (@1 atom) [var: bind-idx])
               (.compile    self (@2 atom) code-pad bind-idx)
               (.op-mov     code-pad out-idx bind-idx)))
           (if (list? (@1 atom))
             (begin
               (do-each (v (@1 atom))
                 (unless (symbol? v)
                   (.error self
                           "'define' parameter list must only contain symbols"
                           v)))
               (let ((bind-idx      (.new-pos self))
                     (var-name      (@0 (@1 atom)))
                     (lambda-params (drop (@1 atom) 1)))
                 (.define-var     self var-name [var: bind-idx])
                 (.compile-lambda self lambda-params (drop atom 2) code-pad bind-idx)
                 (.op-mov         code-pad out-idx bind-idx)))
             (.error self "Can only define symbols as variable" atom)))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'define-macro
       (lambda (atom self code-pad out-idx)
         (unless (> (length atom) 2)
           (.error self "'define-macro' needs at least 2 arguments" atom))
         (define params (@1 atom))
         (unless (list? params)
           (.error self
                   "'define-macro' first argument needs to be a parameter list"
                   params))
         (do-each (v params)
           (unless (symbol? v)
             (.error self
                     "'define-macro' parameter list must consist only of symbols"
                     params)))
         ; XXX TODO FIXME: it's weird, do we want to use already defined macros inside macros?
         ;                 shouldn't we just use a second compiler instance to compile
         ;                 macro-lambdas and make it possible to use other lambdas?
         ;                 In that case, we of course need a way to execute
         ;                 VM-programs and the whole thingie is tied to that.
         ;
         ; => Compiler macro using a one-time-clone of this compiler to generate a completely separate
         ;    PROG with it's own static data table. store the PROG in the env under macro:
         ;      - as we copy the macros too, we are able to expand macros inside
         ;        these compiled macros.
         ;      - Is lambda definition possible? => yes, they are accumulated inside the
         ;        top env, and transmitted inside the PROG each time.
         ;        however, we can't keep around a second VM instance with the current top-env,
         ;        so we need to keep around the whole code for recreating the top env!
         ;
         ; => On expansion:
         ;  
         ))
;         (let ((macro-lambda (eval (append ['lambda (drop params 1)] (drop atom 2)))))
;           (.define-var self (@0 params) [macro: macro-lambda]))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'quote
       (lambda (atom self code-pad out-idx)
         (unless (eqv? 2 (length atom))
           (.error self "'quote' needs exactly 1 argument" atom))
         (.compile-quote self (@1 atom) code-pad out-idx)))
      new-env)))
;----------------------------------------------------------------------------

(lambda (name data debug-info only-compile root-env)
  (let ((compiler (make-static-data-pad debug-info)))
    (hook-compiler-methods compiler)
    ; TODO: Transfer (@0 root-env) as init-env to compiler!

    (unless (not (nil? root-env))
      (error "compiler needs root environment"))
    (when (nil? (@0 root-env))
      (@!0 root-env (.make-base-env compiler)))
    (when (eqv? 0 (length (@0 root-env)))
      (@!0 root-env (.make-base-env compiler)))
    (when (nil? (@1 root-env))
      (@!1 root-env []))

    (.push-root-env compiler root-env)
    (let ((code-pad    (.make-code-pad compiler))
          (ret-val-pos 0))
      ; TODO: we need to calculate the actual sized pad we need in future!
      (do-each (top-level-atom data)
;        (displayln (str "Compile TLA: [" top-level-atom "]"))
        (.compile compiler top-level-atom code-pad ret-val-pos))
;      (displayln ENVPADSIZE: (.cur-env-size compiler))
;      (.op-dump-env-stack code-pad)
      (.op-set-return code-pad ret-val-pos)
;      (displayln PAD: ($pad: compiler))
      (let ((prog (.to-vm-prog compiler code-pad)))
;        (displayln prog)
        (displayln-time (run-vm-prog prog (@1 root-env)))))))
;----------------------------------------------------------------------------

;  (let ((x (make-static-data-pad)))
;    (displayln X: (.add-static-data x "xxx"))
;    (displayln X: (.add-static-data x "xxx"))
;    (displayln X: (.add-static-data x "xxx")))
;  (displayln XXX: name)
;  (displayln YYY: data)
;  (displayln DEBUG-INFO: debug-info)
;  (displayln (atom-id (@0 data)))
;  (@0 (@0 data)))
