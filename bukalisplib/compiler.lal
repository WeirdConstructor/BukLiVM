(define x 10)
;----------------------------------------------------------------------------

(define make-code-pad-object
  (lambda (out-pad)
    (let ((self { code: [] }))

     ($define! self (to-vm-prog-code)
       ($code: self))

     ($define! self (op-push-env size)
       (push! ($code: self) [PUSH_ENV: 0 size]))

     ($define! self (op-pop-env)
       (push! ($code: self) [POP_ENV: 0 0]))

     ($define! self (op-dump-env-stack)
       (push! ($code: self) [DUMP_ENV_STACK: 0 0]))

     ($define! self (op-set-return idx)
       (push! ($code: self) [SET_RETURN: 0 idx]))

     ($define! self (op-load static out-idx)
       (let ((idx (.add-static-data out-pad static)))
         (push! ($code: self) [LOAD_STATIC: out-idx idx])))
     )))
;----------------------------------------------------------------------------

(define make-output-pad
 (lambda ()
   (let ((self { pad: [] }))

     ($define! self (add-static-data data)
       (push! ($pad: self) data)
       (- (length ($pad: self)) 1))

     ($define! self (make-code-pad)
        (make-code-pad-object self))

     ($define! self (to-vm-prog code-pad)
        (make-vm-prog [($pad:  self)
                       (.to-vm-prog-code code-pad)
                       {}]))

     self)))
;----------------------------------------------------------------------------

(define dispatch
 (lambda (key m arg)
   (if (eqv? (@key m) nil)
     (error "unhandled dispatch, for key" key m))

   ((@key m) arg)))
;----------------------------------------------------------------------------

(define type-dispatch
 (lambda (atom m arg arg2 arg3)
   (if (eqv? (@(type atom) m) nil)
     (error (str "unhandled dispatch, for type " (type atom)) atom m))

   ((@(type atom) m) atom arg arg2 arg3)))
;----------------------------------------------------------------------------

(define compile-atom-dispatch-map
 { (type nil) (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'exact     (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'inexact   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'keyword   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'boolean   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'string    (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'map       (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (displayln "GOT MAP" (length atom))
                ; get 2 temporaries k-idx v-idx
                ; op-new-map out-idx
                ; eval key to k-idx
                ; eval value to v-idx
                ; set-map out-idx key-idx value-idx
                (do-each (k v atom)
                  (.compile-atom self k code-pad out-idx)
                  (.compile-atom self v code-pad out-idx)))
   'symbol    (lambda (atom self code-pad out-idx)
                ; lookup symbol, if not found: error
                (displayln "GOT SYM "    atom))
   'list      (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (displayln "GOT LIST")
                (do-each (a atom)
                  (.compile-atom self a code-pad out-idx)))})
;----------------------------------------------------------------------------

(define hook-compiler-methods
 (lambda (self debug-info)
   ($!env-stack:    self [])
   ($!debug-pos:    self nil)

   ($define! self (set-debug-pos atom)
     (let ((info (@(atom-id atom) debug-info)))
       (unless (nil? info)
         ($!debug-pos: self info))))

   ($define! self (error msg atom)
     (error (str-join " " "BukaLISP-Compiler Error: " ($debug-pos: self) msg)
            atom))

   ($define! self (push-env)
     (push! ($env-stack: self) {}))

   ($define! self (pop-env)
     (pop! ($env-stack: self)))

   ($define! self (compile-atom atom code-pad out-idx)
     (type-dispatch atom compile-atom-dispatch-map self code-pad out-idx))))
;----------------------------------------------------------------------------

(lambda (name data debug-info)
  (let ((compiler (make-output-pad)))
;    (displayln FOO: (@'nil { 'nil 1203  }))
    (displayln "INFO:" debug-info)
    (hook-compiler-methods compiler debug-info)

    (let ((code-pad (.make-code-pad compiler)))
      ; TODO: we need to calculate the actual sized pad we need in future!
      (.op-push-env code-pad 1)
      (do-each (top-level-atom data)
        (.compile-atom compiler top-level-atom code-pad 0))
      (.op-dump-env-stack code-pad)
      (.op-set-return code-pad 0)
      (.op-pop-env code-pad)

      (displayln CODE: code-pad)
      (displayln PAD: ($pad: compiler))

      (let ((prog (.to-vm-prog compiler code-pad)))
        (displayln prog)
        (displayln-time (run-vm-prog prog))))))
;----------------------------------------------------------------------------

;  (let ((x (make-output-pad)))
;    (displayln X: (.add-static-data x "xxx"))
;    (displayln X: (.add-static-data x "xxx"))
;    (displayln X: (.add-static-data x "xxx")))
;  (displayln XXX: name)
;  (displayln YYY: data)
;  (displayln DEBUG-INFO: debug-info)
;  (displayln (atom-id (@0 data)))
;  (@0 (@0 data)))
