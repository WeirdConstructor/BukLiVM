(define x 10)
;----------------------------------------------------------------------------

(define make-code-pad-object
  (lambda (out-pad)
    (let ((self { code: [] debug-info: {} }))
      (define push-op
        (lambda (op-desc)
          (@!op-desc
           ($debug-info: self)
           ($debug-pos: out-pad))
          (push! ($code: self) op-desc)))

      ($define! self (append-code-pad code-pad)
        (let ((code ($code: self)))
          (do-each (k v ($debug-info: code-pad))
            (@! k ($debug-info: self) v))
          (do-each (op ($code: code-pad))
            (push! code op))))

      ($define! self (to-vm-prog-code)
        ($code: self))

      ($define! self (to-vm-prog-debug-info)
        (let ((m {}) (i 0))
          (do-each (op-desc ($code: self))
            (@!i m (@op-desc ($debug-info: self)))
            (set! i (+ i 1)))
          m))

      ($define! self (op-push-env size)
        (push-op [PUSH_ENV: 0 size]))

      ($define! self (op-pop-env)
        (push-op [POP_ENV: 0 0]))

      ($define! self (op-dump-env-stack)
        (push-op [DUMP_ENV_STACK: 0 0]))

      ($define! self (op-set-return idx)
        (push-op [SET_RETURN: 0 idx]))

      ($define! self (op-mov out-idx in-idx)
        (push-op [MOV: out-idx in-idx]))

      ($define! self (op-mov-from out-idx env-idx in-idx)
        (push-op [MOV_FROM: out-idx env-idx in-idx]))

      ($define! self (op-mov-to out-idx env-idx in-idx)
        (push-op [MOV_TO: out-idx env-idx in-idx]))

      ($define! self (op-load-prim out-idx prim-nr)
        (push-op [LOAD_PRIM: out-idx prim-nr]))

      ($define! self (op-new-vec out-idx len)
        (push-op [NEW_VEC: out-idx len]))

      ($define! self (op-set-vec vec-idx idx src-idx)
        (push-op [SET_VEC: vec-idx idx src-idx]))

      ($define! self (op-call out-idx func-idx argvec-idx)
        (push-op [CALL: out-idx func-idx argvec-idx]))

      ($define! self (op-load static out-idx)
        ; TODO: optimize static data loading by storing their
        ;       positions in a map
        (let ((idx (.add-static-data out-pad static)))
          (push-op [LOAD_STATIC: out-idx idx]))))))
;----------------------------------------------------------------------------

(define make-static-data-pad
 (lambda (debug-info)
   (let ((self { pad: []
                 debug-pos: nil }))

     ($define! self (set-debug-pos atom)
       (let ((info (@(atom-id atom) debug-info)))
         (unless (nil? info)
           ($!debug-pos: self info))))

     ($define! self (add-static-data data)
       (push! ($pad: self) data)
       (- (length ($pad: self)) 1))

     ($define! self (make-code-pad)
        (make-code-pad-object self))

     ($define! self (to-vm-prog code-pad)
        (make-vm-prog [($pad:  self)
                       (.to-vm-prog-code       code-pad)
                       (.to-vm-prog-debug-info code-pad)]))

     self)))
;----------------------------------------------------------------------------

(define dispatch
 (lambda (key m arg)
   (if (eqv? (@key m) nil)
     (error "unhandled dispatch, for key" key m))

   ((@key m) arg)))
;----------------------------------------------------------------------------

(define type-dispatch
 (lambda (atom m arg arg2 arg3)
   (if (eqv? (@(type atom) m) nil)
     (error (str "unhandled dispatch, for type " (type atom)) atom m))

   ((@(type atom) m) atom arg arg2 arg3)))
;----------------------------------------------------------------------------

(define compile-atom-dispatch-map
 { (type nil) (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'exact     (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'inexact   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'keyword   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'boolean   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'string    (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'map       (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (displayln "GOT MAP" (length atom))
                ; get 2 temporaries k-idx v-idx
                ; op-new-map out-idx
                ; eval key to k-idx
                ; eval value to v-idx
                ; set-map out-idx key-idx value-idx
                (let ((k-idx (.new-tmp-pos self))
                      (v-idx (.new-tmp-pos self)))
                  (do-each (k v atom)
                   (.compile-atom self k code-pad k-idx)
                   (.compile-atom self v code-pad v-idx))
                  (.recycle-tmp-pos self k-idx)
                  (.recycle-tmp-pos self v-idx)))
   'symbol    (lambda (atom self code-pad out-idx)
                ; lookup symbol, if not found: error
                (displayln "GOT SYM "    atom)
                (.op-load code-pad atom out-idx))
   'list      (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (displayln "GOT LIST")
                (do-each (a atom)
                  (displayln DO-LIST_ITEM: a)
                  (.compile-atom self a code-pad out-idx)))})
;----------------------------------------------------------------------------

(define compile-expr-dispatch-map
 { (type nil) (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'exact     (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'inexact   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'keyword   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'boolean   (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'string    (lambda (atom self code-pad out-idx)
                (.op-load code-pad atom out-idx))
   'map       (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (displayln "GOT MAP" (length atom))
                ; get 2 temporaries k-idx v-idx
                ; op-new-map out-idx
                ; eval key to k-idx
                ; eval value to v-idx
                ; set-map out-idx key-idx value-idx
                (let ((k-idx (.new-tmp-pos self))
                      (v-idx (.new-tmp-pos self)))
                  (do-each (k v atom)
                    (.compile self k code-pad k-idx)
                    (.compile self v code-pad v-idx))
                  (.recycle-tmp-pos self k-idx)
                  (.recycle-tmp-pos self v-idx)))

   'symbol    (lambda (atom self code-pad out-idx)
                (let ((var (.lookup self atom)))
                  (when (nil? var)
                    (.error self "Undefined variable" atom))
                  (case (@0 (@1 var))
                    ((var:)
                     (let ((var-idx (@1 (@1 var))))
                       (if (> (@0 var) 0)
                         (.op-mov-from code-pad out-idx (@0 var) var-idx)
                         (.op-mov      code-pad out-idx var-idx))))
                    ((syntax:)
                     (let ((prim-nr (@2 (@1 var))))
                       (when (nil? prim-nr)
                         (.error self "Syntax is not translatable to a primitive" atom))
                       (.op-load-prim code-pad out-idx prim-nr)))
                    (else
                      (.error self "Not a value binding variable" atom)))))

   'list      (lambda (atom self code-pad out-idx)
                (.set-debug-pos self atom)
                (case (type (@0 atom))
                  ((symbol)
                   (let ((var (.lookup self (@0 atom))))
                     (when (nil? var)
                       (.error self "Undefined variable" (@0 atom)))
                     (case (@0 (@1 var))
                       ((syntax:)
                        (displayln SYN:)
                        (if (nil? (@2 (@1 var)))
                          ((@1 (@1 var)) atom self code-pad out-idx)
                          (.compile-func-apply self atom code-pad out-idx)))
                       (else
                         (.error self "Bad variable type" var)))))
                  (else
                    (.error self "Invalid atom type at start of list" atom))))})
;                (do-each (a atom)
;                  (displayln DO-LIST_ITEM: a)
;                  (.compile-atom self a code-pad out-idx)))})
;----------------------------------------------------------------------------

(define recursive-lookup
  (lambda (env-stack lvl-idx sym)
    (let ((cur-env (@(- (length env-stack)
                        (+ 1 lvl-idx))
                     env-stack))
          (var-type (@sym cur-env))
          (next-lvl-idx (+ 1 lvl-idx)))
      (if (nil? var-type)
        (when (< next-lvl-idx (length env-stack))
          (recursive-lookup env-stack next-lvl-idx sym))
        [lvl-idx var-type]))))
;----------------------------------------------------------------------------

(define hook-compiler-methods
 (lambda (self)
   ($!env-stack:     self [])
   ($!env-pos-stack: self [])

   ($define! self (error msg atom)
     (error (str-join " " "BukaLISP-Compiler Error: " ($debug-pos: self) msg)
            atom))

   ($define! self (new-tmp-pos)
     (let ((env-pos (last ($env-pos-stack: self)))
           (free-tmp-pos-list (@1 env-pos)))
       (if (> (length free-tmp-pos-list) 0)
         (pop! free-tmp-pos-list)
         (let ((new-pos (+ 1 (@0 env-pos))))
           (@!0 env-pos new-pos)
           new-pos))))

   ($define! self (new-pos)
     (let ((env-pos (last ($env-pos-stack: self)))
           (new-pos (+ 1 (@0 env-pos))))
       (@!0 env-pos new-pos)
       new-pos))

   ($define! self (recycle-tmp-pos pos)
     (push! (@1 (last ($env-pos-stack: self))) pos))

   ($define! self (define-var sym var-type)
     (let ((cur-env (last ($env-stack: self))))
       (@!sym cur-env var-type)))

   ($define! self (lookup sym)
     (recursive-lookup ($env-stack: self) 0 sym))

   ($define! self (push-env)
     (push! ($env-pos-stack: self) [0 []])
     (push! ($env-stack: self) {}))

   ($define! self (cur-env-size)
     (+ 1 (@0 (last ($env-pos-stack: self)))))

   ($define! self (pop-env)
     (pop! ($env-pos-stack: self))
     (pop! ($env-stack: self)))

   ($define! self (compile-func-apply atom code-pad out-idx)
      ; eval all items (func a b c) into temporary registers
      ; make new vec
      ; set vec from tmp registers
      ; do a CALL with the index of the function and the index of the arg vector
      ; CALL figures out what to do with #<primitive> or #<closure>
     (let ((end-idx    (- (length atom) 1))
           (func-idx   (.new-tmp-pos self))
           (argvec-idx (.new-tmp-pos self))
           (arg-idxes []))

       (.compile self (@0 atom) code-pad func-idx)

       (for (i 1 end-idx)
         (let ((arg-idx (.new-tmp-pos self)))
           (push! arg-idxes arg-idx)
           (.compile self (@i atom) code-pad arg-idx)))

       (.op-new-vec code-pad argvec-idx (- (length atom) 1))
       (for (i 0 (- end-idx 1))
         (.op-set-vec code-pad argvec-idx i (@i arg-idxes)))
       (.op-call code-pad out-idx func-idx argvec-idx)))

   ($define! self (compile-block block code-pad out-idx)
     (do-each (expr block)
       (.compile self expr code-pad out-idx)))

   ($define! self (compile atom code-pad out-idx)
     (type-dispatch atom compile-expr-dispatch-map self code-pad out-idx))

   ($define! self (compile-atom atom code-pad out-idx)
     (type-dispatch atom compile-atom-dispatch-map self code-pad out-idx))))
;----------------------------------------------------------------------------

(define make-prim-syntax
  (lambda (compiler symbol compiler-func prim-nr)
    (.define-var compiler symbol [syntax: compiler-func prim-nr])))

(define make-syntax
  (lambda (compiler symbol compiler-func)
    (.define-var compiler symbol [syntax: compiler-func])))

(define init-base-env
  (lambda (compiler)
    (make-prim-syntax compiler '+
     (lambda (atom self code-pad out-idx) 0)
     0)
;       (unless (< 2 (length atom))
;         (.error self "'+' needs 3 arguments" atom))
;       (unless (symbol? (@1 atom))
;         (.error self "Can only define symbols as variable" atom))
;
;       (let ((bind-idx (.new-pos self)))
;         (.define-var self (@1 atom) [var: bind-idx])
;         (.compile self (@2 atom) code-pad bind-idx)
;         (.op-mov code-pad out-idx bind-idx))))

    (make-syntax compiler 'define
     (lambda (atom self code-pad out-idx)
       (unless (eqv? 3 (length atom))
         (.error self "'define' needs 3 arguments" atom))
       (unless (symbol? (@1 atom))
         (.error self "Can only define symbols as variable" atom))

       (let ((bind-idx (.new-pos self)))
         (.define-var self (@1 atom) [var: bind-idx])
         (.compile self (@2 atom) code-pad bind-idx)
         (.op-mov code-pad out-idx bind-idx))))))
;----------------------------------------------------------------------------

(lambda (name data debug-info)
  (let ((compiler (make-static-data-pad debug-info)))
;    (displayln FOO: (@'nil { 'nil 1203  }))
    (displayln "INFO:" debug-info)
    (hook-compiler-methods compiler)
    (.push-env compiler)
    (init-base-env compiler)

    (let ((code-pad (.make-code-pad compiler)))
      ; TODO: we need to calculate the actual sized pad we need in future!
      (.op-push-env code-pad 1)
      (do-each (top-level-atom data)
        (displayln (str "Compile TLA: [" top-level-atom "]"))
        (.compile compiler top-level-atom code-pad 0))
;      (displayln ENVPADSIZE: (.cur-env-size compiler))
      (.op-dump-env-stack code-pad)
      (.op-set-return code-pad 0)
      (.op-pop-env code-pad)

      (displayln PAD: ($pad: compiler))

      (let ((prog (.to-vm-prog compiler code-pad)))
        (displayln prog)
        (displayln-time (run-vm-prog prog))))))
;----------------------------------------------------------------------------

;  (let ((x (make-static-data-pad)))
;    (displayln X: (.add-static-data x "xxx"))
;    (displayln X: (.add-static-data x "xxx"))
;    (displayln X: (.add-static-data x "xxx")))
;  (displayln XXX: name)
;  (displayln YYY: data)
;  (displayln DEBUG-INFO: debug-info)
;  (displayln (atom-id (@0 data)))
;  (@0 (@0 data)))
