(define x 10)
;----------------------------------------------------------------------------

(define make-code-pad-object
  (lambda (out-pad)
    (let ((self { code: [] }))

     ($define! self (to-vm-prog-code)
       ($code: self))

     ($define! self (op-push-env size)
       (push! ($code: self) [PUSH_ENV: 0 size]))

     ($define! self (op-pop-env)
       (push! ($code: self) [POP_ENV: 0 0]))

     ($define! self (op-dump-env-stack)
       (push! ($code: self) [DUMP_ENV_STACK: 0 0]))

     ($define! self (op-set-return idx)
       (push! ($code: self) [SET_RETURN: 0 idx]))

     ($define! self (op-load static out-idx)
       (let ((idx (.add-static-data out-pad static)))
         (push! ($code: self) [LOAD_STATIC: out-idx idx])))
     )))
;----------------------------------------------------------------------------

(define make-output-pad
 (lambda ()
   (let ((self { pad: [] }))

     ($define! self (add-static-data data)
       (push! ($pad: self) data)
       (- (length ($pad: self)) 1))

     ($define! self (make-code-pad)
        (make-code-pad-object self))

     ($define! self (to-vm-prog code-pad)
        (make-vm-prog [($pad:  self)
                       (.to-vm-prog-code code-pad)
                       {}]))

     self)))
;----------------------------------------------------------------------------

(define dispatch
 (lambda (key m arg)
   (if (eqv? (@key m) nil)
     (error "unhandled dispatch, for key" key m))

   ((@key m) arg)))
;----------------------------------------------------------------------------

(define type-dispatch
 (lambda (atom m arg arg2 arg3)
   (if (eqv? (@(type atom) m) nil)
     (error "unhandled dispatch, for type " (type atom) m))

   ((@(type atom) m) atom arg arg2 arg3)))
;----------------------------------------------------------------------------

(define compile-atom-dispatch-map
 { 'nil      (lambda (atom self code-pad out-idx) (displayln "GOT NIL!"))
   'exact    (lambda (atom self code-pad out-idx)
               (.op-load code-pad atom out-idx))
   'inexact  (lambda (atom self code-pad out-idx) (displayln "GOT DNUM "   atom))
   'keyword  (lambda (atom self code-pad out-idx) (displayln "GOT KW "     atom))
   'symbol   (lambda (atom self code-pad out-idx) (displayln "GOT SYM "    atom))
   'boolean  (lambda (atom self code-pad out-idx) (displayln "GOT BOOL "   atom))
   'string   (lambda (atom self code-pad out-idx) (displayln "GOT STRING " atom))
   'list     (lambda (atom self code-pad out-idx)
               (displayln "GOT LIST")
               (do-each (a atom)
                 (.compile-atom self a code-pad out-idx)))
   'map      (lambda (atom self code-pad out-idx)
               (displayln "GOT MAP")
               (do-each (k v atom)
                 (.compile-atom self k code-pad out-idx)
                 (.compile-atom self v code-pad out-idx)))})
;----------------------------------------------------------------------------

(define hook-compiler-methods
 (lambda (self)
   ($!env-stack: self [])

   ($define! self (push-env)
     (push! ($env-stack: self) {}))

   ($define! self (pop-env)
     (pop! ($env-stack: self)))

   ($define! self (compile-atom atom code-pad out-idx)
     (type-dispatch atom compile-atom-dispatch-map self code-pad out-idx))))
;----------------------------------------------------------------------------

(lambda (name data debug_info)
  (let ((compiler (make-output-pad)))
    (hook-compiler-methods compiler)

    (let ((code-pad (.make-code-pad compiler)))
      ; TODO: we need to calculate the actual sized pad we need in future!
      (.op-push-env code-pad 1)
      (do-each (top-level-atom data)
        (.compile-atom compiler top-level-atom code-pad 0))
      (.op-dump-env-stack code-pad)
      (.op-set-return code-pad 0)
      (.op-pop-env code-pad)

      (displayln CODE: code-pad)
      (displayln PAD: ($pad: compiler))

      (let ((prog (.to-vm-prog compiler code-pad)))
        (displayln prog)
        (displayln-time (run-vm-prog prog))))))
;----------------------------------------------------------------------------

;  (let ((x (make-output-pad)))
;    (displayln X: (.add-static-data x "xxx"))
;    (displayln X: (.add-static-data x "xxx"))
;    (displayln X: (.add-static-data x "xxx")))
;  (displayln XXX: name)
;  (displayln YYY: data)
;  (displayln DEBUG-INFO: debug_info)
;  (displayln (atom-id (@0 data)))
;  (@0 (@0 data)))
