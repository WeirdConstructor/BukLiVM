;----------------------------------------------------------------------------
(displayln START-COMPILER-COMPILE:)
(include "compiler/stage2.bkl")

;----------------------------------------------------------------------------
(define *DEBUG* #f)
(define PUSH-DEBUG (lambda () (set! *DEBUG* #t)))
(define POP-DEBUG (lambda () (set! *DEBUG* #f)))

(define global-saved-eval-vm-closure nil)

(define bukalisp-compile
  (lambda (name expr root-env only-compile?)
;    (displayln CALL-COMPILER: name STATISTICS: (bkl-gc-statistics))
    (unless (@" IS-ROOT-ENV " root-env)
      (init-root-env root-env))
    ; Wrap up eval-syntax into a closure, to hide it's syntactic nature
    ; from callers more throughout.
;    (when (eqv? (@0 (@'eval root-env)) prim:)
;;      (displayln START-COMPILE-EVAL:)
;      (let ((local-root (spawn-root-env))
;            (eval-closure global-saved-eval-vm-closure))
;        (when (nil? eval-closure)
;          (let ((eval-prog (bukalisp-compile
;                             "<internal-eval>"
;                             '((lambda (code . env)
;                                 (displayln INT-EVAL: code)
;                                 (let ((ret (if (empty? env)
;                                   (eval code)
;                                   (eval code (first env)))))
;                                   (displayln RET-EVAL: ret)
;                                   ret)))
;                             (assign local-root
;                                     ['eval [syntax: eval-syntax]])
;                             #t)))
;            (set! global-saved-eval-vm-closure
;              (bkl-run-vm eval-prog))
;            (set! eval-closure global-saved-eval-vm-closure)))
;;        (displayln ENDED-COMPILE-EVAL:)
;        (set-root-env-var root-env 'eval eval-closure)))
    ; Attach the root env map as meta to the root env registers, so we
    ; have a chance to recover it in the VM later.
    (bkl-set-meta (@" REGS " root-env) 1 root-env)
    (let ((s1-ctx   {env:         root-env
                     include-dir: "bukalisplib"})
          (s1-gtx   {root-env:    root-env
                     'lib-compiler bukalisp-compile
                     gensym-counter: 0})
          (s1prog (stage1-transformator
                    (if (eqv? name "<vm-op-eval>")
                      expr
                      (DI! expr (append 'begin expr)))
                    s1-ctx
                    s1-gtx)))
      (when *DEBUG* (displayln (pp-str s1prog)))
      (let ((gtx {root-env:    {" REGS " (@" REGS " root-env)}})
            (frame (make-s2-frame gtx))
            (ctx {F:            frame
                  P:            (make-code-pad-object frame)
                  env:          {}})
            (adr (stage2-transformer s1prog ctx gtx))
            (P (P: ctx)))
        (.op-return P adr)
        (let ((prog (.to-vm-prog (F: ctx) P name root-env)))
          (when *DEBUG* (displayln PROG: prog))
          (unless (or (eqv? name ".\\bukalisplib\\compiler.bkl")
                      (eqv? (substring name 0 1) "<"))
            (let ((comp-at (userdata->atom prog)))
              (sys-write-file
                (str name ".bklc")
                (pp-str comp-at))))
          (if only-compile?
            prog
            (bkl-run-vm prog)))))))
;----------------------------------------------------------------------------

(displayln END-COMPILER-COMPILE:)
bukalisp-compile
