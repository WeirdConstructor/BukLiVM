;----------------------------------------------------------------------------
(include "compiler/stage2.bkl")

;----------------------------------------------------------------------------
(define *DEBUG* #f)
(define PUSH-DEBUG (lambda () (set! *DEBUG* #t)))
(define POP-DEBUG (lambda () (set! *DEBUG* #t)))

(define global-saved-eval-vm-closure nil)

(define bukalisp-compile
  (lambda (name expr root-env only-compile?)
    (unless (@" IS-ROOT-ENV " root-env)
      (init-root-env root-env))
    ; Wrap up eval-syntax into a closure, to hide it's syntactic nature
    ; from callers more throughout.
    (when (eqv? (@0 (@'eval root-env)) prim:)
;      (displayln START-COMPILE-EVAL:)
      (let ((local-root (spawn-root-env))
            (eval-closure global-saved-eval-vm-closure))
        (when (nil? eval-closure)
          (let ((eval-prog (bukalisp-compile
                             "<internal-eval>"
                             '((lambda (code . env)
                                 (if (empty? env)
                                   (eval code)
                                   (eval code (first env)))))
                             (assign local-root
                                     ['eval [syntax: eval-syntax]])
                             #t)))
            (set! global-saved-eval-vm-closure
              (run-vm-prog eval-prog local-root))
            (set! eval-closure global-saved-eval-vm-closure)))
;        (displayln ENDED-COMPILE-EVAL:)
        (set-root-env-var root-env 'eval eval-closure)))
    ; Attach the root env map as meta to the root env registers, so we
    ; have a chance to recover it in the VM later.
    (bkl-set-meta (@" REGS " root-env) 1 root-env)
    (let ((s1-ctx   {env:         root-env
                     include-dir: "bukalisplib"})
          (s1-gtx   {root-env:    root-env
                     var-counter: 0})
          (s1prog (stage1-transformator
                    (if (eqv? name "<vm-op-eval>")
                      expr
                      (DI! expr (append 'begin expr)))
                    s1-ctx
                    s1-gtx)))
      (when *DEBUG* (displayln (pp-str s1prog)))
      (let ((gtx {root-env:    {" REGS " (@" REGS " root-env)}})
            (frame (make-s2-frame gtx))
            (ctx {F:            frame
                  P:            (make-code-pad-object frame)
                  env:          {}})
            (adr (stage2-transformer s1prog ctx gtx))
            (P (P: ctx)))
        (.op-return P adr)
;        (displayln DEBUG-INFO: adr (pp-str (.to-vm-prog-debug-info P)))
;        (displayln ROOT-ENV: (pp-str (root-env: gtx)))
        (let ((prog (.to-vm-prog (F: ctx) P)))
          (when *DEBUG* (displayln PROG: prog))
          (if only-compile?
            prog
            (run-vm-prog prog root-env)))))))
;----------------------------------------------------------------------------

bukalisp-compile
