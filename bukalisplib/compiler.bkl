(define primitive-table
'{<= 7 symbol? 12 + 0 * 1 / 2 = 4 - 3 < 5 append 42 keyword? 13 > 6 >= 8 first 39 exact? 15 list 9 eqv? 10 map? 20 not 11 nil? 14 inexact? 16 string? 17 bkl-slurp-file 44 boolean? 18 write-str 43 @! 23 list? 19 get-vm-modules 30 pop! 27 procedure? 21 @ 22 type 24 display 32 length 25 push! 26 make-vm-prog 28 str-join 37 run-vm-prog 29 error 31 newline 33 eval 46 displayln 34 atom-id 35 str 36 last 38 take 40 drop 41 bkl-gc-statistics 45 invoke-compiler 47}
)
;----------------------------------------------------------------------------

(define inc-env-offs
 (lambda (out-adr)
   [(@0 out-adr)
    (+ 1 (@1 out-adr))
    (@2 out-adr)]))
;----------------------------------------------------------------------------

(define dec-env-offs
 (lambda (out-adr)
   [(@0 out-adr)
    (- (@1 out-adr) 1)
    (@2 out-adr)]))
;----------------------------------------------------------------------------

(include prog-frame)
(include code-pad)

;----------------------------------------------------------------------------
(define find-max-number-in-values
  (lambda (min-nr the-map fetch_func)
    (define max-nr min-nr)
    (define cur min-nr)
    (do-each (k v the-map)
      (set! cur (fetch_func k v the-map))
      (when (< max-nr cur)
        (set! max-nr cur)))
    max-nr))

;----------------------------------------------------------------------------

(define dispatch
 (lambda (key m arg)
   (if (eqv? (@key m) nil)
     (error "unhandled dispatch, for key" key m))

   ((@key m) arg)))
;----------------------------------------------------------------------------

(define type-dispatch
 (lambda (atom m arg arg2 arg3)
   (if (eqv? (@(type atom) m) nil)
     (error (str "unhandled dispatch, for type " (type atom)) atom m))

   ((@(type atom) m) atom arg arg2 arg3)))
;----------------------------------------------------------------------------

(define compile-quote-dispatch-map
 { (type nil) (lambda (atom self code-pad)
                (.store-static-data self atom))
   'exact     (lambda (atom self code-pad)
                (.store-static-data self atom))
   'inexact   (lambda (atom self code-pad)
                (.store-static-data self atom))
   'keyword   (lambda (atom self code-pad)
                (.store-static-data self atom))
   'boolean   (lambda (atom self code-pad)
                (.store-static-data self atom))
   'string    (lambda (atom self code-pad)
                (.store-static-data self atom))
   'symbol    (lambda (atom self code-pad)
                (.store-static-data self atom))

   'map       (lambda (atom self code-pad)
                (.set-debug-pos self atom)
                (let ((ret-adr (.new-tmp-pos self)))
                  (.op-new-map code-pad ret-adr)
                  (do-each (k v atom)
                    (.set-debug-pos self atom)
                    (let ((k-adr (.compile-quote self k code-pad))
                          (v-adr (.compile-quote self v code-pad)))
                      (.op-cset-vec code-pad ret-adr k-adr v-adr)
                      (.recycle-pos self k-adr)
                      (.recycle-pos self v-adr)))
                  ret-adr))

   'list      (lambda (atom self code-pad)
                (let ((vec-adr (.new-tmp-pos self))
                      (i 0))
                  (.op-new-vec code-pad vec-adr (length atom))
                  (do-each (a atom)
                    (.set-debug-pos self atom)
                    (let ((val-adr (.compile-quote self a code-pad)))
                      (.op-cset-vec code-pad vec-adr i val-adr)
                      (.recycle-pos self val-adr)
                      (set! i (+ i 1))))
                  vec-adr))})
;----------------------------------------------------------------------------

(define compile-expr-dispatch-map
 { (type nil) (lambda (atom self code-pad)
                (.store-static-data self atom))
   'exact     (lambda (atom self code-pad)
                (.store-static-data self atom))
   'inexact   (lambda (atom self code-pad)
                (.store-static-data self atom))
   'keyword   (lambda (atom self code-pad)
                (.store-static-data self atom))
   'boolean   (lambda (atom self code-pad)
                (.store-static-data self atom))
   'string    (lambda (atom self code-pad)
                (.store-static-data self atom))

   'map       (lambda (atom self code-pad)
                (.set-debug-pos self atom)
                (let ((ret-adr (.new-tmp-pos self)))
                  (.op-new-map code-pad ret-adr)
                  (do-each (k v atom)
                    (.set-debug-pos self atom)
                    (let ((k-adr (.compile self k code-pad))
                          (v-adr (.compile self v code-pad)))
                      (.op-cset-vec code-pad ret-adr k-adr v-adr)
                      (.recycle-pos self k-adr)
                      (.recycle-pos self v-adr)))
                  ret-adr))

   'symbol    (lambda (atom self code-pad)
                (let ((var (.lookup self atom)))
                  (when (nil? var)
                    (.error self "Undefined variable" atom))
                  (case (@0 (@1 var))
                    ((var:)
                     [(@1 (@1 var)) (@0 var)])
                    ((prim:)
                     [(@1 (@1 var)) -2])
                    ((syntax:)
                     (let ((prim-nr (@2 (@1 var))))
                       (when (nil? prim-nr)
                         (.error self "Syntax is not translatable to a primitive" atom))
                       [prim-nr -2]))
                    (else
                      (.error self "Not a value binding variable" atom)))))

   'list      (lambda (atom self code-pad)
                (.set-debug-pos self atom)
                (case (type (@0 atom))
                  ((symbol)
                   (let ((var (.lookup self (@0 atom))))
                     (when (nil? var)
                       (.error self "Undefined variable" (@0 atom)))
                     (case (@0 (@1 var))
                       ((prim:)
                        (.compile-func-apply self atom code-pad))
                       ((syntax:)
                        ((@1 (@1 var)) atom self code-pad))
                       ((var:)
                        (.compile-func-apply self atom code-pad))
                       (else
                         (.error self "Bad variable type" var)))))
                  ((list)
                   (.compile-func-apply self atom code-pad))
                  (else
                    (.error self "Invalid atom type at start of list" atom))))})
;                (do-each (a atom)
;                  (displayln DO-LIST_ITEM: a)
;                  (.compile-quote self a code-pad)))})
;----------------------------------------------------------------------------

(define recursive-lookup
  (lambda (env-stack lvl-idx sym)
    (let ((cur-env (@(- (length env-stack)
                        (+ 1 lvl-idx))
                     env-stack))
          (var-type (@sym cur-env))
          (next-lvl-idx (+ 1 lvl-idx)))
      (if (nil? var-type)
        (when (< next-lvl-idx (length env-stack))
          (recursive-lookup env-stack next-lvl-idx sym))
        [lvl-idx var-type]))))
;----------------------------------------------------------------------------

(define set-env-syntax-prim
  (lambda (env symbol compiler-func prim-nr)
    (@!symbol env [syntax: compiler-func prim-nr])))
;----------------------------------------------------------------------------

(define set-env-syntax
  (lambda (env symbol compiler-func)
    (@!symbol env [syntax: compiler-func])))
;----------------------------------------------------------------------------

(define hook-compiler-methods
  (lambda (self)
    ($!env-stack:     self [])
    ($!env-pos-stack: self [])
    ($!macro-compiler: self [])

;    ($define! self (clone-compiler)
;      (let ((p-frame (make-prog-frame ($debug-info: self))))
;        (hook-compiler-methods p-frame)
;        (.copy-env-from p-frame self)
;        p-frame))
;
;    ($define! self (copy-env-from other-compiler)
;      (.push-env self)
;      (do-each (sym var (first ($env-stack: other-compiler)))
;        (when (eqv? (@0 var) syntax:) (.define-var self sym var))
;        (when (eqv? (@0 var) prim:)   (.define-var self sym var))
;        (when (eqv? (@0 var) macro:)  (.define-var self sym var))))
;
    ($define! self (error msg atom)
      (error (str-join " " "BukaLISP-Compiler Error: " ($debug-pos: self) msg)
             atom))

    ($define! self (new-tmp-pos)
      (let ((env-pos (last ($env-pos-stack: self)))
            (free-tmp-pos-list (@1 env-pos)))
        (if (> (length free-tmp-pos-list) 0)
          [(pop! free-tmp-pos-list) 0 tmp:]
          (let ((new-pos (@0 env-pos)))
            (@!0 env-pos (+ new-pos 1))
            [new-pos 0 tmp:]))))

    ($define! self (new-pos)
      (let ((env-pos (last ($env-pos-stack: self)))
            (new-pos (@0 env-pos)))
        (@!0 env-pos (+ 1 new-pos))
        [new-pos 0]))

    ($define! self (recycle-pos pos)
      (when (eqv? (@2 pos) tmp:)
        (push! (@1 (last ($env-pos-stack: self)))
          (if (list? pos)
            (@0 pos)
            pos)))
      pos)

    ($define! self (adr-in-cur-env? adr)
      (eqv? (@1 adr) 0))

    ($define! self (adr-in-env? adr)
      (>= (@1 adr) 0))

    ($define! self (define-var sym var-type)
      (let ((cur-env (last ($env-stack: self))))
        (@!sym cur-env var-type)))

    ($define! self (lookup sym)
      (recursive-lookup ($env-stack: self) 0 sym))

    ($define! self (push-env)
      (push! ($env-pos-stack: self) [0 []])
      (push! ($env-stack: self) {}))

    ($define! self (cur-env-size)
      (+ 1 (@0 (last ($env-pos-stack: self)))))

    ($define! self (pop-env)
      (pop! ($env-pos-stack: self))
      (pop! ($env-stack: self)))

    ($define! self (compile-get obj key eval-key? code-pad)
      (let ((out-adr (.new-tmp-pos self))
            (key-adr (if eval-key?
                       (.compile self key code-pad)
                       (.store-static-data self key)))
            (obj-adr (.compile self obj code-pad)))
          (.op-get code-pad out-adr obj-adr key-adr)
          (.recycle-pos self obj-adr)
          (.recycle-pos self key-adr)
          out-adr))

    ($define! self (compile-set obj key eval-key? value code-pad)
      (let ((key-adr (if eval-key?
                       (.compile self key code-pad)
                       (.store-static-data self key)))
            (obj-adr (.compile self obj code-pad))
            (val-adr (.compile self value code-pad)))
          (.op-set code-pad obj-adr key-adr val-adr)
          (.recycle-pos self obj-adr)
          (.recycle-pos self key-adr)
          val-adr))

    ($define! self (compile-func-apply atom code-pad)
      ; eval all items (func a b c) into temporary registers
      ; make new vec
      ; set vec from tmp registers
      ; do a CALL with the index of the function and the index of the arg vector
      ; CALL figures out what to do with #<primitive> or #<closure>
      (let ((func-adr       (.compile self (@0 atom) code-pad))
            (argvec-adr     (.new-tmp-pos self))
            (argc           (- (length atom) 1)))
        (.op-new-vec code-pad argvec-adr argc)
        (when (> argc 0)
          (for (i 1 argc)
            (.set-debug-pos self atom)
            (let ((arg-adr (.compile self (@i atom) code-pad)))
              (.op-cset-vec code-pad argvec-adr (- i 1) arg-adr)
              (.recycle-pos self arg-adr))))
        (let ((ret-adr (.new-tmp-pos self)))
          (.op-call code-pad ret-adr func-adr argvec-adr)
          (.recycle-pos self argvec-adr)
          ret-adr)))

    ($define! self (compile-lambda parameters body code-pad)
      (.push-prog-frame self)
      (.push-env self)
      (define dot-var-adr  #f)
      (do-each (var parameters)
        (unless (symbol? var)
          (.error self "Can't use non symbol in lambda parameter list" var))
        (if dot-var-adr
          (if (eqv? (type dot-var-adr) 'exact)
            (.error self "After a '.' only one symbol can follow" parameters)
            (.define-var self var [var: (@0 (set! dot-var-adr (.new-pos self)))]))
          (begin
            (if (eqv? var '.)
              (set! dot-var-adr #t)
              (.define-var self var [var: (@0 (.new-pos self))])))))
      (when dot-var-adr
        (unless (list? dot-var-adr)
          (.error self "'.' must follow a symbol" parameters)))
      (let ((lambda-code-pad (.make-code-pad self)))
        (when dot-var-adr
          (.op-pack-va lambda-code-pad dot-var-adr dot-var-adr))
        (let ((body-res-adr (.compile-block self body lambda-code-pad)))
          (.op-return lambda-code-pad body-res-adr)
          (let ((new-prog (.to-vm-prog self lambda-code-pad)))
            (.pop-env               self)
            (.pop-prog-frame        self)
            (let ((ret-adr (.new-tmp-pos self)))
              (.op-new-closure
                code-pad
                ret-adr
                (.store-static-data self new-prog))
              ret-adr)))))

    ($define! self (compile-one-branch-condition
                    code-pad
                    compile-as-block?
                    negated?
                    branch-atom
                    condition-atom)
       (let ((branch-pad     (.make-code-pad self))
             (branch-ret-adr (if compile-as-block?
                               (.compile-block self branch-atom branch-pad)
                               (.compile       self branch-atom branch-pad)))
             (cond-adr       (.compile self condition-atom code-pad))
             (cond-ret-adr   (.new-tmp-pos self)))
         (.op-load-nil     code-pad cond-ret-adr)
         (.op-mov          branch-pad cond-ret-adr branch-ret-adr)
         (if negated?
           (.op-brif  code-pad (.count-ops branch-pad) cond-adr)
           (.op-brnif code-pad (.count-ops branch-pad) cond-adr))
         (.append-code-pad code-pad branch-pad)
         (.recycle-pos self cond-adr)
         (.recycle-pos self branch-ret-adr)
         cond-ret-adr))

    ($define! self (compile-block block code-pad)
      (let ((ret-adr nil))
        (do-each (expr block)
          (unless (nil? ret-adr)
            (.recycle-pos self ret-adr))
          (set! ret-adr (.compile self expr code-pad))
          ret-adr)))

    ($define! self (compile atom code-pad)
      (type-dispatch atom compile-expr-dispatch-map self code-pad))

    ($define! self (compile-quote atom code-pad)
      (type-dispatch atom compile-quote-dispatch-map self code-pad))

    ($define! self (push-root-env root-env)
      (push! ($env-stack: self) (@0 root-env))
      (define max-pos
       (find-max-number-in-values -1 (@0 root-env) (lambda (k v)
                                                     (if (eqv? var: (@0 v))
                                                       (@1 v)
                                                       -1))))
      (set! max-pos (+ 1 max-pos))
      (push! ($env-pos-stack: self) [max-pos []]))

    ($define! self (make-base-env)
      (define new-env {})

      (do-each (k v primitive-table)
        (@!k new-env [prim: v]))
      ;----------------------------------------------------------------------------

      (define make-bin-op-syntax
        (lambda (op-sym op-func only-supports-2-args?)
          (set-env-syntax-prim
           new-env op-sym
           (lambda (atom self code-pad)
             (when (< (length atom) 2)
               (.error self (str "'" op-sym "' needs at least 1 arguments") atom))
             (define out-adr (.new-tmp-pos self))
             (if (eqv? (length atom) 2)
               (begin
                 (define a-adr (.new-tmp-pos self))
                 (define b-adr (.compile self (@1 atom) code-pad))
                 (.op-load-nil code-pad a-adr)
                 (op-func code-pad out-adr a-adr b-adr)
                 (.recycle-pos self a-adr)
                 (.recycle-pos self b-adr))
               (if (eqv? (length atom) 3)
                 (begin
                   (define a-adr (.compile self (@1 atom) code-pad))
                   (define b-adr (.compile self (@2 atom) code-pad))
                   (op-func code-pad out-adr a-adr b-adr)
                   (.recycle-pos self a-adr)
                   (.recycle-pos self b-adr))
                 (begin
                   (if only-supports-2-args?
                     (begin
                        (.recycle-pos self out-adr)
                        (set! out-adr (.compile-func-apply self atom code-pad)))
                     (begin
                       (define recycle-addrs [])
                       (define add-recylcle
                         (lambda (a)
                           (push! recycle-addrs a)
                           a))
                       (.op-mov code-pad out-adr (add-recylcle
                                                   (.compile self (@1 atom) code-pad)))
                       (do-each (v (drop atom 2))
                         (op-func code-pad
                                  out-adr
                                  out-adr
                                  (add-recylcle (.compile self v code-pad))))
                       (do-each (r-adr recycle-addrs)
                         (.recycle-pos self r-adr)))))))
             out-adr)
           (@op-sym primitive-table))))


      (make-bin-op-syntax
       '+
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-add code-pad out-adr a-adr b-adr)))

      (make-bin-op-syntax
       '-
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-sub code-pad out-adr a-adr b-adr)))

      (make-bin-op-syntax
       '*
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-mul code-pad out-adr a-adr b-adr)))

      (make-bin-op-syntax
       '/
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-div code-pad out-adr a-adr b-adr)))

      (make-bin-op-syntax
       '%
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-mod code-pad out-adr a-adr b-adr)))

      (make-bin-op-syntax
       '=
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-eq code-pad out-adr a-adr b-adr))
       #t)

      (make-bin-op-syntax
       '>
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-gt code-pad out-adr a-adr b-adr))
       #t)

      (make-bin-op-syntax
       '<
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-lt code-pad out-adr a-adr b-adr))
       #t)

      (make-bin-op-syntax
       '>=
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-ge code-pad out-adr a-adr b-adr))
       #t)

      (make-bin-op-syntax
       '<=
       (lambda (code-pad out-adr a-adr b-adr)
         (.op-le code-pad out-adr a-adr b-adr))
       #t)
;
      ;
      ;       (let ((bind-idx (.new-pos self)))
      ;         (.define-var self (@1 atom) [var: bind-idx])
      ;         (.compile self (@2 atom) code-pad bind-idx)
      ;         (.op-mov code-pad out-idx bind-idx))

;      (set-env-syntax new-env '+

      (set-env-syntax new-env 'begin
       (lambda (atom self code-pad)
         (.compile-block self (drop atom 1) code-pad)))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'lambda
       (lambda (atom self code-pad)
         (.compile-lambda self (@1 atom) (drop atom 2) code-pad)))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'let
       (lambda (atom self code-pad)
         (unless (> (length atom) 1)
           (.error self "'let' needs at least 1 argument (the binding list)" atom))
         (unless (eqv? (type (@1 atom)) 'list)
           (.error self "'let' binding list needs to be a list" atom))
         (let ((env-size 0))
           (do-each (bind-pair (@1 atom))
             (unless (eqv? (type bind-pair) 'list)
               (.error self "'let' binding pair needs to be a list" bind-pair))
             (unless (eqv? (length bind-pair) 2)
               (.error self "'let' binding pair needs exactly 2 elements" bind-pair))
             (unless (eqv? (type (@0 bind-pair)) 'symbol)
               (.error self "'let' binding pair must contain a symbol as first element" bind-pair))
             (set! env-size (+ env-size 1)))
           (let ((out-adr (inc-env-offs (.new-tmp-pos self))))
             (.push-env    self)
             (.op-push-env code-pad env-size)
             (do-each (bind-pair (@1 atom))
               (let ((var-adr (.new-pos self)))
                 (.define-var self (@0 bind-pair) [var: (@0 var-adr)])
                 (let ((val-adr (.compile self (@1 bind-pair) code-pad)))
                   (.op-mov code-pad var-adr val-adr)
                   (.recycle-pos self val-adr))))
             (let ((ret-adr (.compile-block self (drop atom 2) code-pad)))
               ; Now optimize returning non-local-variables from the environment:
               (if (.adr-in-cur-env? self ret-adr)
                 (begin
                   (.op-mov code-pad out-adr ret-adr)
                   (.recycle-pos self ret-adr)
                   (set! out-adr (dec-env-offs out-adr)))
                 (begin
                   (set! out-adr ret-adr)
                   (.recycle-pos self out-adr)
                   (when (.adr-in-env? self out-adr)
                     (set! out-adr (dec-env-offs out-adr)))))
               (.op-pop-env code-pad)
               (.pop-env self)
               out-adr)))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'set!
       (lambda (atom self code-pad)
         (unless (eqv? 3 (length atom))
           (.error self "'set!' needs 2 arguments" atom))
         (unless (symbol? (@1 atom))
           (.error self "Can only use set! on a symbol" atom))
         (let ((var (.lookup self (@1 atom))))
           (when (nil? var)
             (.error self "Undefined variable" atom))
           (let ((var-adr [(@1 (@1 var)) (@0 var)])
                 (val-adr (.compile self (@2 atom) code-pad)))
             (when (eqv? (@0 (@1 var)) var:)
               (.op-mov code-pad var-adr val-adr)
               (.recycle-pos self val-adr)
               var-adr)))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'define
       (lambda (atom self code-pad)
         (unless (> (length atom) 2)
           (.error self "'define' needs at least 2 arguments" atom))
         (if (symbol? (@1 atom))
           (begin
             (unless (eqv? 3 (length atom))
               (.error self "'define' needs 2 arguments" atom))
             (let ((var (.lookup self (@1 atom)))
                   (bind-adr nil))
               (if (nil? var)
                 (set! bind-adr (.new-pos self))
                 (if (eqv? var: (@0 (@1 var)))
                   (set! bind-adr [(@1 (@1 var)) (@0 var)])
                   (set! bind-adr (.new-pos self))))
               (.define-var self (@1 atom) [var: (@0 bind-adr)])
               (let ((val-adr (.compile self (@2 atom) code-pad)))
                 (.op-mov code-pad bind-adr val-adr)
                 (.recycle-pos self val-adr))
               bind-adr))
           (if (list? (@1 atom))
             (begin
               (do-each (v (@1 atom))
                 (unless (symbol? v)
                   (.error self
                           "'define' parameter list must only contain symbols"
                           v)))
               (let ((bind-adr      (.new-pos self))
                     (var-name      (@0 (@1 atom)))
                     (lambda-params (drop (@1 atom) 1)))
                 (.define-var self var-name [var: (@0 bind-adr)])
                 (let ((lambda-adr (.compile-lambda self
                                                    lambda-params
                                                    (drop atom 2)
                                                    code-pad)))
                   (.op-mov code-pad bind-adr lambda-adr)
                   (.recycle-pos self lambda-adr))
                 bind-adr))
             (.error self "Can only define symbols as variable" atom)))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'return
       (lambda (atom self code-pad)
         (unless (eqv? (length atom) 2)
           (.error self "'return' needs exactly 1 argument" atom))
         (.op-return code-pad (.compile self (@1 atom) code-pad))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'if
       (lambda (atom self code-pad)
         (unless (> (length atom) 2)
           (.error self "'if needs at least 2 arguments" atom))
         (if (eqv? (length atom) 4)
           (let ((true-pad      (.make-code-pad self))
                 (false-pad     (.make-code-pad self))
                 (cond-adr      (.compile self (@1 atom) code-pad))
                 (true-ret-adr  (.compile self (@2 atom) true-pad))
                 (false-ret-adr (.compile self (@3 atom) false-pad))
                 (cond-ret-adr  (.new-tmp-pos self)))
             (.op-mov true-pad  cond-ret-adr true-ret-adr)
             (.op-mov false-pad cond-ret-adr false-ret-adr)
             (.op-brnif               code-pad (+ 1 (.count-ops true-pad)) cond-adr)
             (.append-code-pad        code-pad true-pad)
             (.op-br                  code-pad (.count-ops false-pad))
             (.append-code-pad        code-pad false-pad)
             (.recycle-pos self true-ret-adr)
             (.recycle-pos self false-ret-adr)
             (.recycle-pos self cond-adr)
             cond-ret-adr)
           (.compile-one-branch-condition self code-pad #f #f (@2 atom) (@1 atom)))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'when
       (lambda (atom self code-pad)
         (unless (> (length atom) 2)
           (.error self "'when' needs at least 1 argument" atom))
         (.compile-one-branch-condition self code-pad #t #f (drop atom 2) (@1 atom))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'unless
       (lambda (atom self code-pad)
         (unless (> (length atom) 2)
           (.error self "'unless needs at least 1 argument" atom))
         (.compile-one-branch-condition self code-pad #t #t (drop atom 2) (@1 atom))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'for
       (lambda (atom self code-pad)
         (unless (> (length atom) 2)
           (.error self "'for' needs at least 1 argument" atom))
         (unless (list? (@1 atom))
           (.error self "first argument of 'for' needs to be a list" atom))
         (unless (> (length (@1 atom)) 2)
           (.error self "first part of the iteration definition of \
                         'for' needs to contain at least 3 elements" atom))
         (when (> (length (@1 atom)) 4)
           (.error self "first part of the iteration definition of \
                         'for' contains too many elements (only 3 or 4 allowed)" atom))
         (unless (symbol? (@0 (@1 atom)))
           (.error self "first part of the iteration definition of \
                         'for' needs to be a symbol" atom))
         (define for-ret-adr (inc-env-offs (.new-tmp-pos self)))
         (.push-env self)
         (.op-push-env code-pad 5) ; at least 5 temporaries for the loop
         (let ((i-def         (@1 atom))
               (iter-name     (@0 i-def))
               (start-val     (@1 i-def))
               (end-val       (@2 i-def))
               (iter-val      (@3 i-def))

               (start-val-adr (.compile self start-val code-pad))
               (end-val-adr   (.compile self end-val   code-pad))
               (step-val-adr  (if (nil? iter-val)
                                (.store-static-data self 1)
                                (.compile self iter-val code-pad)))
               (cond-res-adr  (.new-pos self))
               (iter-adr      (.new-pos self))
               (body-pad      (.make-code-pad self)))
           (.define-var self iter-name [var: (@0 iter-adr)])
           (.op-mov code-pad iter-adr start-val-adr)
           (define body-ret-adr
                   (.compile-block self (drop atom 2) body-pad))
;           (.op-eq  body-pad cond-res-adr iter-adr end-val-adr)
;           (.op-inc body-pad iter-adr step-val-adr)
           ; XXX: iter-adr is implicitly passed with cond-res-adr, as the
           ;      following address is automatically fetched!
           ; INCFOR step-val-adr iter-adr
           (.op-load-nil code-pad cond-res-adr)
           (.op-br code-pad (.count-ops body-pad))
           (.append-code-pad code-pad body-pad)
           (.op-forinc code-pad cond-res-adr step-val-adr end-val-adr)
           (.op-brnif  code-pad
                       (- 0 (+ 2 (.count-ops body-pad)))
                       cond-res-adr)
           (.op-mov    code-pad for-ret-adr body-ret-adr)
           ; cleanup:
           (.op-pop-env code-pad)
           (.pop-env self)
           (dec-env-offs for-ret-adr))))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'define-macro
       (lambda (atom self code-pad)
         (unless (> (length atom) 2)
           (.error self "'define-macro' needs at least 2 arguments" atom))
         (define params (@1 atom))
         (unless (list? params)
           (.error self
                   "'define-macro' first argument needs to be a parameter list"
                   params))
         (do-each (v params)
           (unless (symbol? v)
             (.error self
                     "'define-macro' parameter list must consist only of symbols"
                     params)))
         ; XXX TODO FIXME: it's weird, do we want to use already defined macros inside macros?
         ;                 shouldn't we just use a second compiler instance to compile
         ;                 macro-lambdas and make it possible to use other lambdas?
         ;                 In that case, we of course need a way to execute
         ;                 VM-programs and the whole thingie is tied to that.
         ;
         ; => Compiler macro using a one-time-clone of this compiler to generate a completely separate
         ;    PROG with it's own prog frame. store the PROG in the env under macro:
         ;      - as we copy the macros too, we are able to expand macros inside
         ;        these compiled macros.
         ;      - Is lambda definition possible? => yes, they are accumulated inside the
         ;        top env, and transmitted inside the PROG each time.
         ;        however, we can't keep around a second VM instance with the current top-env,
         ;        so we need to keep around the whole code for recreating the top env!
         ;
         ; => On expansion:
         ;  
         ))
;         (let ((macro-lambda (eval (append ['lambda (drop params 1)] (drop atom 2)))))
;           (.define-var self (@0 params) [macro: macro-lambda]))
      ;----------------------------------------------------------------------------

      (set-env-syntax new-env 'quote
       (lambda (atom self code-pad)
         (unless (eqv? 2 (length atom))
           (.error self "'quote' needs exactly 1 argument" atom))
         (.compile-quote self (@1 atom) code-pad)))

      (set-env-syntax new-env '$
       (lambda (atom self code-pad)
         (unless (eqv? (length atom) 3)
           (.error self "'$' needs exactly 2 arguments" atom))
         (.compile-get self
                       (@2 atom)
                       (@1 atom)
                       (not
                        (or (symbol?  (@1 atom))
                            (keyword? (@1 atom))
                            (string?  (@1 atom))))
                       code-pad)))

      (set-env-syntax new-env '$!
       (lambda (atom self code-pad)
         (unless (eqv? (length atom) 4)
           (.error self "'$!' needs exactly 2 arguments" atom))
         (.compile-set self
                       (@2 atom)
                       (@1 atom)
                       (not
                        (or (symbol?  (@1 atom))
                            (keyword? (@1 atom))
                            (string?  (@1 atom))))
                       (@3 atom)
                       code-pad)))

      (set-env-syntax-prim new-env '@
       (lambda (atom self code-pad)
         (unless (eqv? (length atom) 3)
           (.error self "'@' needs exactly 2 arguments" atom))
         (.compile-get self (@2 atom) (@1 atom) #true code-pad))
       (@'@ primitive-table))

      (set-env-syntax-prim new-env '@!
       (lambda (atom self code-pad)
         (unless (eqv? (length atom) 4)
           (.error self "'@!' needs exactly 3 arguments" atom))
         (.compile-set self (@2 atom) (@1 atom) #true (@3 atom) code-pad))
       (@'@! primitive-table))

      (set-env-syntax new-env 'do-each
       (lambda (atom self code-pad)
         (unless (> (length atom) 2)
           (.error self "'do-each' needs at least 2 arguments" atom))
         (define iter-desc (@1 atom))
         (unless (list? iter-desc)
           (.error self
                   (str "first argument to 'do-each' "
                        "needs to be an iteration description list")
                   atom))
         (when (< (length iter-desc) 2)
           (.error self
                   "iteration description must be at least 2 elements long"
                   iter-desc))
         (when (> (length iter-desc) 3)
           (.error self
                   "iteration description too long (2 or 3 elements allowed)"
                   iter-desc))
         (unless (symbol? (@0 iter-desc))
           (.error self
                   "first element of iteration description must be a symbol"
                   iter-desc));
         (define obj-atom (@1 iter-desc))
         (when (eqv? (length iter-desc) 3)
           (define obj-atom (@2 iter-desc))
           (unless (symbol? (@1 iter-desc))
             (.error self
                     "second element of iteration description must be a symbol"
                     iter-desc)));
         (define ret-adr (inc-env-offs (.new-tmp-pos self)))
         (.push-env self)
         (.op-push-env code-pad 5)
         (let ((body-pad    (.make-code-pad self))
               (map-adr     (.compile self obj-atom code-pad))
               (ok-adr      (.new-pos self))
               (val-adr     (.new-pos self))
               (iter-adr    (.new-pos self))
               (key-adr     nil)
               (with-key?   (eqv? (length iter-desc) 3)))
           ; initialization:
           (.define-var self (@0 iter-desc) [var: (@0 val-adr)])
           (when with-key?
             (set! key-adr (.new-pos self))
             (.define-var self (@1 iter-desc)
                          [var: (@0 key-adr)]))
           (define body-ret-adr
                   (.compile-block self (drop atom 2) body-pad))
           (.op-load-nil code-pad ret-adr)
           ; start iteration:
           (.op-iter     code-pad iter-adr map-adr)
           (.op-next     code-pad ok-adr val-adr iter-adr)
           (when with-key?
             (.op-ikey code-pad key-adr iter-adr))
           ; branch:
           (define body-op-count (.count-ops body-pad))
           (.op-br  code-pad (+ 2 body-op-count))
           (.append-code-pad code-pad body-pad)
           (.op-mov code-pad ret-adr body-ret-adr)
           (.op-next  code-pad ok-adr val-adr iter-adr)
           (when with-key?
             (.op-ikey code-pad key-adr iter-adr))
           (.op-brnif code-pad
                      (- 0 (+ (if with-key? 7 3)
                              body-op-count))
                      ok-adr)
           ; cleanup:
           (.op-pop-env code-pad)
           (.pop-env self)
           (dec-env-offs ret-adr))))

#|

  map-reg <= NEW_MAP
  ; iter-reg recieved vector with map (for keepalive) and iteration value:
  ITER iter-reg map-reg
  NEXT ok-reg val-reg iter-reg
  BRNIF ok-reg after:
  ; this one can be skipped for vectors, however, for vectors it should store the current index:
  IKEY key-reg state-reg 
  MOV k-reg key-reg
  MOV v-reg val-reg
  ...

after:
  PUSH_NIL ...
  ...

|#

      new-env)))
;----------------------------------------------------------------------------

(lambda (name data debug-info only-compile root-env)
  (let ((compiler (make-prog-frame debug-info)))
    (hook-compiler-methods compiler)

    (unless (not (nil? root-env))
      (error "compiler needs root environment"))
    (when (nil? (@0 root-env))
      (@!0 root-env (.make-base-env compiler)))
    (when (eqv? 0 (length (@0 root-env)))
      (@!0 root-env (.make-base-env compiler)))
    (when (nil? (@1 root-env))
      (@!1 root-env [nil]))

;    (displayln (str "ROOTENV: " root-env))

    (.push-root-env compiler root-env)
    (let ((code-pad    (.make-code-pad compiler))
          (ret-adr     nil))
      ; TODO: we need to calculate the actual sized pad we need in future!
      (do-each (top-level-atom data)
;        (displayln (str "Compile TLA: [" top-level-atom "]"))
        (unless (nil? ret-adr)
          (.recycle-pos compiler ret-adr))
        (set! ret-adr
         (.compile compiler top-level-atom code-pad)))
;      (displayln ENVPADSIZE: (.cur-env-size compiler))
;      (.op-dump-env-stack code-pad)
      (.op-set-return code-pad ret-adr)
      (.recycle-pos compiler ret-adr)
;      (displayln PAD: ($pad: compiler))
      (let ((prog (.to-vm-prog compiler code-pad)))
        (displayln prog)
        (if only-compile
          prog
          (run-vm-prog prog (@1 root-env)))))))
;          (displayln-time (run-vm-prog prog (@1 root-env))))))))
;----------------------------------------------------------------------------

;  (let ((x (make-prog-frame)))
;    (displayln X: (.store-static-data x "xxx"))
;    (displayln X: (.store-static-data x "xxx"))
;    (displayln X: (.store-static-data x "xxx")))
;  (displayln XXX: name)
;  (displayln YYY: data)
;  (displayln DEBUG-INFO: debug-info)
;  (displayln (atom-id (@0 data)))
;  (@0 (@0 data)))
