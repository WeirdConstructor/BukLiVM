;----------------------------------------------------------------------------

(add-syntax
  'quote
  (lambda (ctx args T gtx) (.S1-T-Q gtx ctx (@1 args))))
;----------------------------------------------------------------------------

(add-syntax
  'unquote
  (lambda (ctx args T gtx) (T ctx (@1 args))))
;----------------------------------------------------------------------------

(add-syntax
  'begin
  (lambda (ctx args T gtx) (s1-begin T ctx (drop args 1))))
;----------------------------------------------------------------------------

(add-syntax
  'if
  (lambda (ctx args T gtx)
    (when (< (length args) 3)
      (error "'if' needs at least 2 arguments" args))
    (when (> (length args) 4)
      (error "'if' can not have more than 3 arguments" args))
    (if (= (length args) 3)
      ['#1#if (T ctx (@1 args)) (T ctx (@2 args)) (T ctx nil)]
      ['#1#if (T ctx (@1 args)) (T ctx (@2 args)) (T ctx (@3 args))])))
;----------------------------------------------------------------------------

(add-syntax
  'unless
  (lambda (ctx args T gtx)
    (when (< (length args) 3)
      (error "'unless' needs at least 2 arguments" args))
    ['#1#if
     (.AM gtx ['#1#not (T ctx (@1 args))])
     (.AM gtx (s1-begin T ctx (drop args 2)))
     (.AM gtx '(#1#nil))]))
;----------------------------------------------------------------------------

(add-syntax
  'when
  (lambda (ctx args T gtx)
    (when (< (length args) 3)
      (error "'when' needs at least 2 arguments" args))
    ['#1#if
     (T ctx (@1 args))
     (.AM gtx (s1-begin T ctx (drop args 2)))
     (.AM gtx '(#1#nil))]))
;----------------------------------------------------------------------------

(add-syntax
  'set!
  (lambda (ctx args T gtx)
    (unless (symbol? (@1 args))
      (error "'set!' expected symbol as first argument" args))
    (unless (= (length args) 3)
      (error "'set!' needs exactly 2 arguments" args))
    (let ((var-t (T ctx (@1 args))))
      (append '#1#set! [var-t (T ctx (@2 args))]))))
;----------------------------------------------------------------------------

(add-syntax
  'return
  (lambda (ctx args T gtx)
    (unless (= (length args) 2)
      (error "'return' needs exactly 1 arguments" args))
    (append '#1#return (T ctx (@1 args)))))
;----------------------------------------------------------------------------

(add-syntax
  'yield
  (lambda (ctx args T gtx)
    (unless (= (length args) 2)
      (error "'yield needs exactly 1 arguments" args))
    (append '#1#yield (T ctx (@1 args)))))
;----------------------------------------------------------------------------

(define only-in-first
 (lambda (a b)
   (define out [])
   (do-each (v a)
     (define found? #f)
     (do-each (w b)
       (if (eqv? v w) (set! found? #t)))
     (unless found?
       (push! out v)))
   out))
;----------------------------------------------------------------------------

(add-syntax
  'lambda
  (lambda (ctx args T gtx)
    (define lambda-name nil)
    (when (not (nil? (lambda-name: ctx)))
      (set! lambda-name (lambda-name: ctx))
      (set! ctx (cpassign ctx lambda-name: nil)))
    (unless (> (length args) 2)
      (error "'lambda' needs more than 1 argument" args))
    (define lambda-params
      (parse-lambda-params
        (@1 args)
        (lambda (msg a)
          (error (str "'lambda' parameter error: " msg) a))))
    (let ((new-env {" PARENT "         (env: ctx)
                   " LAMBDA-UPV "     {}})
          (new-args [])
          (va-arg nil)
          (new-ctx (cpassign ctx env: new-env)))
      (do-each (s (args: lambda-params))
        (let ((new-var-name (gtx-gensym gtx s)))
          (push! new-args new-var-name)
          (@!s new-env [var: new-var-name s])))
      (unless (nil? (varargs-param: lambda-params))
        (let ((va-arg-name  (varargs-param: lambda-params))
              (new-var-name (gtx-gensym gtx va-arg-name)))
          (@!va-arg-name new-env [var: new-var-name va-arg-name])
          (set! va-arg new-var-name)))
      (let ((compiled-body
              (.AM gtx (s1-begin T new-ctx (drop args 2))))
            (lambda-upv
              (if (> (length (@" LAMBDA-UPV " new-env)) 0)
                (keys-in-map (@" LAMBDA-UPV " new-env))
                nil)))
        (append
          '#1#lambda
          (.AM gtx (if (nil? va-arg)
                     [[lambda-name new-args nil    lambda-upv]]
                     [[lambda-name new-args va-arg lambda-upv]]))
          (if (found-upv-in-env? new-env)
            (let ((defined-upvalues
                   (only-in-first (upvalues-in-env new-env) new-args))
                  (upv-body ['#1#create-upv
                             lambda:
                             (upvalues-in-env new-env)
                             compiled-body]))
              (if (> (length defined-upvalues) 0)
                [['#1#let defined-upvalues upv-body]]
                [upv-body]))
            [compiled-body]))))))
;----------------------------------------------------------------------------

(define compile-let-block
  (lambda (ctx T gtx var-binds body-compile-func)
    (let ((new-env           { " PARENT " (env: ctx) })
          (new-ctx           (cpassign ctx env: new-env))
          (let-new-var-names [])
          (body              (.AM gtx ['#1#begin]))
          (out-form          ['#1#let let-new-var-names body]))
      (do-each (bind-pair var-binds)
        (let ((bind-name    (@0 bind-pair))
              (new-var-name (gtx-gensym gtx bind-name))
              (var-t        [var: new-var-name bind-name]))
          (@!bind-name new-env var-t)
          (push! let-new-var-names new-var-name)
          (push! body (.AM gtx ['#1#set!
                                (append '#1#var (drop var-t 1))
                                (T (cpassign
                                     new-ctx
                                     lambda-name: bind-name)
                                   (@1 bind-pair))]))))
      (let ((compiled-body
             (body-compile-func new-ctx T gtx)))
        (push! body compiled-body)
        (if (found-upv-in-env? new-env)
          ['#1#let
           (append
             let-new-var-names
             (only-in-first
               (upvalues-in-env new-env)
               let-new-var-names))
           ['#1#create-upv let: (upvalues-in-env new-env) body]]
          ['#1#let let-new-var-names body])))))
;----------------------------------------------------------------------------

(add-syntax
  'let
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (error "'let' needs more than 1 argument" args))
    (let ((var-binds (@1 args)))
      (unless (list? var-binds)
        (error "'let' binding list needs to be a list" var-binds))
      (do-each (bind-pair var-binds)
        (unless (list? bind-pair)
          (error "'let' binding pair needs to be a list" bind-pair))
        (unless (= (length bind-pair) 2)
          (error "'let' binding pair needs exactly 2 elements" bind-pair))
        (unless (symbol? (@0 bind-pair))
          (error "'let' binding pair must contain a symbol as first element" bind-pair)))
      (compile-let-block
       ctx T gtx
       var-binds
       (lambda (ctx T gtx)
         (s1-begin T ctx (drop args 2)))))))
;----------------------------------------------------------------------------

(add-syntax
  'define
  (lambda (ctx args T gtx)
    (define is-root-env?
      (@" IS-ROOT-ENV " (env: ctx)))
    (case (type (@1 args))
      ((symbol) (unless (= (length args) 3)
                  (error (str "'define' needs exactly 2 arguments if "
                              "first is a symbol")
                         args))
                (let ((var-name (@1 args))
                      (var        nil)
                      (var-s1-sym nil))
                  (if is-root-env?
                    (begin
                      (set! var-s1-sym '#1#glob-var)
                      (set! var [glob-var: var-name]))
                    (begin
                      (set! var-s1-sym '#1#var)
                      (let ((new-var-name (gtx-gensym gtx var-name)))
                        (set! var [var: new-var-name var-name]))))
                  (@!var-name (env: ctx) var)
                  ['#1#set! (append var-s1-sym (drop var 1))
                   (T (cpassign ctx lambda-name: var-name)
                      (@2 args))]))
      ((list) (unless (> (length args) 2)
                (error (str "'define' for function define needs "
                            "at least 3 arguments")
                       args))
              (do-each (s (@1 args))
                (unless (symbol? s)
                  (error (str "'define' for function requires the "
                              "first argument be a list only "
                              "of symbols")
                         (@1 args))))
              (let ((func-name      (@0 (@1 args)))
                    (var-s1-sym     nil)
                    (var            nil))
                (if is-root-env?
                  (begin
                    (set! var-s1-sym '#1#glob-var)
                    (set! var [glob-var: func-name]))
                  (begin
                    (set! var-s1-sym '#1#var)
                    (let ((new-var-name (gtx-gensym gtx func-name)))
                      (set! var [var: new-var-name func-name]))))
                (@!func-name (env: ctx) var)
                ['#1#set! (append var-s1-sym (drop var 1))
                 (T (cpassign ctx lambda-name: func-name)
                    (.AM gtx
                         (append
                           'lambda
                           (.AM gtx [(drop (@1 args) 1)])
                           (drop args 2))))]))
      (else
        (error "'define' unexpected first argument" args)))))
;----------------------------------------------------------------------------

(add-syntax
  'define-macro
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (error "'define-macro' needs at least 2 arguments" args))
    (define params (@1 args))
    (unless (list? params)
      (error "'define-macro' first argument needs to be a parameter list"
             params))
    (do-each (v params)
      (unless (symbol? v)
        (error "'define-macro' parameter list must consist only of symbols"
               params)))
    (define macro-name (first params))
    (define macro-func
      (eval (.AM gtx (append ['lambda (drop params 1)]
                             (drop args 2)))))
    (@!macro-name (env: ctx)
                  [macro: macro-func macro-name])
    (.AM gtx ['#1#nil])))
;----------------------------------------------------------------------------

(add-syntax
  'include
  (lambda (ctx args T gtx)
    (unless (= (length args) 2)
      (error "'include' needs exactly 1 argument" args))
    (let ((include-file-path (str (include-dir: ctx)
                                  (sys-path-separator)
                                  (@1 args)))
          (include-content (sys-slurp-file
                             include-file-path))
          (read-data       (read-str include-content
                                     include-file-path))
          (new-ctx (cpassign ctx
                             include-dir:
                             (first (sys-path-split
                                      include-file-path)))))
      (with-cleanup
        (push! (meta-stack: gtx) [include-file-path 1])
        (pop! (meta-stack: gtx))
        (s1-begin T new-ctx read-data)))))
;----------------------------------------------------------------------------

(add-syntax
  '$define!
  (lambda (ctx args T gtx)
     (unless (> (length args) 3)
       (error "'$define!' needs at least 3 arguments" atom))
     (unless (list? (@2 args))
       (error "'$define!' second argument needs to be a list" atom))
     (unless (> (length (@2 args)) 0)
       (error "'$define!' second argument list needs at least 1 symbol" atom))
     (do-each (v (@2 args))
       (unless (symbol? v)
         (error
           "'$define!' parameter list may only contain symbols"
           (@2 args))))
    ['#1#set method:
     ['#1#data (first (@2 args))]
     (T ctx (@1 args))
     (T (cpassign ctx lambda-name: (first (@2 args)))
        (.AM
          gtx
          (append
            'lambda
            (.AM gtx [(drop (@2 args) 1)])
            (drop args 3))))]))
;----------------------------------------------------------------------------

(add-syntax
  'do-each
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (error "'do-each' needs at least 2 arguments" args))
    (define iter-desc (@1 args))
    (unless (list? iter-desc)
      (error
        (str "first argument to 'do-each' "
             "needs to be an iteration description list")
        args))
    (when (< (length iter-desc) 2)
      (error
        "iteration description must be at least 2 elements long"
        iter-desc))
    (when (> (length iter-desc) 3)
      (error
        "iteration description too long (2 or 3 elements allowed)"
        iter-desc))
    (unless (symbol? (@0 iter-desc))
      (error
        "key bind name of iteration description must be a symbol"
        iter-desc));
    (define obj-atom (@1 iter-desc))
    (if (eqv? (length iter-desc) 3)
      (begin
        (define obj-atom (@2 iter-desc))
        (unless (symbol? (@1 iter-desc))
          (error "value bind name of iteration description must be a symbol"
                 iter-desc))
        (define obj (T ctx obj-atom))
        (compile-let-block
          ctx T gtx
          (.AM gtx [[(@0 iter-desc) nil]
                    [(@1 iter-desc) nil]])
          (lambda (ctx T gtx)
            ['#1#do-each
             [(T ctx (@0 iter-desc))
              (T ctx (@1 iter-desc))]
             obj
             (s1-begin T ctx (drop args 2))])))
      ;TODO FIXME: Global variables should not be an up value!
      ;            But how do we prevent namespace collisions?
      ;            (#1#var vs #1#glob-var!)
      ;            For that we need to add the corresponding
      ;            code everywhere!
      (begin
        (define obj (T ctx obj-atom))
        (compile-let-block
          ctx T gtx
          (.AM gtx [[(@0 iter-desc) nil]])
          (lambda (ctx T gtx)
            ['#1#do-each
             [(T ctx (@0 iter-desc))]
             obj
             (s1-begin T ctx (drop args 2))]))
        ))))
;----------------------------------------------------------------------------

(add-syntax
  '.
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (error "method call needs at least 2 arguments (method & object)" args))
    (let ((method-name (@1 args))
          (obj         (@2 args))
          (m-args      (drop args 3)))
      (unless (or (symbol? method-name)
                  (keyword? method-name)
                  (string? method-name))
        (set! method-name (T ctx method-name)))
      (append
        '#1#method-call
        [method-name]
        [(T ctx obj)]
        (.AM gtx (map (lambda (v) (T ctx v)) m-args))))))
;----------------------------------------------------------------------------

