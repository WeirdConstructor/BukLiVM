;----------------------------------------------------------------------------

(define only-in-first
 (lambda (a b)
   (define out [])
   (do-each (v a)
     (define found? #f)
     (do-each (w b)
       (if (eqv? v w) (set! found? #t)))
     (unless found?
       (push! out v)))
   out))
;----------------------------------------------------------------------------

(define compile-let-block
  (lambda (ctx T gtx var-binds body-compile-func)
    (let ((new-env           { " PARENT " (env: ctx) })
          (let-new-var-names [])
          (new-ctx           (assign ctx [env:      new-env
                                          let-vars: let-new-var-names]))
          (body              (.AM gtx ['#s1#begin]))
          (out-form          ['#s1#let let-new-var-names body]))
      (do-each (bind-pair var-binds)
        (let ((bind-name    (@0 bind-pair))
              (new-var-name (gtx-gensym gtx bind-name))
              (var-t        [var: new-var-name bind-name]))
          (@!bind-name new-env var-t)
          (push! let-new-var-names new-var-name)
          (push! body (.AM gtx ['#s1#set!
                                (append '#s1#var (drop var-t 1))
                                (T (assign
                                     new-ctx
                                     [lambda-name: bind-name])
                                   (@1 bind-pair))]))))
      (let ((compiled-body
             (body-compile-func new-ctx T gtx)))
        (push! body compiled-body)
        (when (= (length body) 2)
          (set! body (@1 body)))
        (if (found-upv-in-env? new-env)
          ['#s1#let
           (append
             let-new-var-names
             (only-in-first
               (upvalues-in-env new-env)
               let-new-var-names))
           ['#s1#create-upv let: (upvalues-in-env new-env) body]]
          ['#s1#let let-new-var-names body])))))
;----------------------------------------------------------------------------

(add-syntax
  'quote
  (lambda (ctx args T gtx) (.S1-T-Q gtx ctx (@1 args))))
;----------------------------------------------------------------------------

(add-syntax
  'unquote
  (lambda (ctx args T gtx) (T ctx (@1 args))))
;----------------------------------------------------------------------------

(add-syntax
  'begin
  (lambda (ctx args T gtx) (s1-begin T ctx (drop args 1))))
;----------------------------------------------------------------------------

(add-syntax
  'if
  (lambda (ctx args T gtx)
    (when (< (length args) 3)
      (compiler-error gtx ctx "'if' needs at least 2 arguments" args))
    (when (> (length args) 4)
      (compiler-error gtx ctx "'if' can not have more than 3 arguments" args))
    (if (= (length args) 3)
      ['#s1#if (T ctx (@1 args)) (T ctx (@2 args)) (T ctx nil)]
      ['#s1#if (T ctx (@1 args)) (T ctx (@2 args)) (T ctx (@3 args))])))
;----------------------------------------------------------------------------

(add-syntax
  'unless
  (lambda (ctx args T gtx)
    (when (< (length args) 3)
      (compiler-error gtx ctx "'unless' needs at least 2 arguments" args))
    ['#s1#if
     (.AM gtx ['#s1#not (T ctx (@1 args))])
     (.AM gtx (s1-begin T ctx (drop args 2)))
     (.AM gtx '(#s1#nil))]))
;----------------------------------------------------------------------------

(add-syntax
  'when
  (lambda (ctx args T gtx)
    (when (< (length args) 3)
      (compiler-error gtx ctx "'when' needs at least 2 arguments" args))
    ['#s1#if
     (T ctx (@1 args))
     (.AM gtx (s1-begin T ctx (drop args 2)))
     (.AM gtx '(#s1#nil))]))
;----------------------------------------------------------------------------

(add-syntax
  'set!
  (lambda (ctx args T gtx)
    (unless (symbol? (@1 args))
      (compiler-error gtx ctx "'set!' expected symbol as first argument" args))
    (unless (= (length args) 3)
      (compiler-error gtx ctx "'set!' needs exactly 2 arguments" args))
    (let ((var-t (T ctx (@1 args))))
      (append '#s1#set! [var-t (T ctx (@2 args))]))))
;----------------------------------------------------------------------------

(add-syntax
  'return
  (lambda (ctx args T gtx)
    (unless (= (length args) 2)
      (compiler-error gtx ctx "'return' needs exactly 1 arguments" args))
    (append '#s1#return [(T ctx (@1 args))])))
;----------------------------------------------------------------------------

(add-syntax
  'yield
  (lambda (ctx args T gtx)
    (unless (= (length args) 2)
      (compiler-error gtx ctx "'yield' needs exactly 1 arguments" args))
    (append '#s1#yield [(T ctx (@1 args))])))
;----------------------------------------------------------------------------

(add-syntax
  'current-coroutine
  (lambda (ctx args T gtx)
    (unless (= (length args) 1)
      (compiler-error gtx ctx "'current-coroutine' takes no arguments" args))
    ['#s1#current-coroutine]))
;----------------------------------------------------------------------------

(add-syntax
  'bkl-vm-stack-trace
  (lambda (ctx args T gtx)
    (unless (= (length args) 1)
      (compiler-error gtx ctx "'bkl-vm-stack-trace' takes no arguments" args))
    ['#s1#stack-trace (T ctx (@1 args))]))
;----------------------------------------------------------------------------

(add-syntax
  'raise
  (lambda (ctx args T gtx)
    (unless (= (length args) 2)
      (compiler-error gtx ctx "'raise' needs exactly 1 arguments" args))
    (append '#s1#return-from [['#s1#data nil] (T ctx (@1 args))])))
;----------------------------------------------------------------------------

(add-syntax
  'handle-exceptions
  (lambda (ctx args T gtx)
    (unless (> (length args) 3)
      (compiler-error gtx ctx "'handle-exceptions' needs at least 3 arguments" args))
    (unless (symbol? (@1 args))
      (compiler-error gtx ctx "'handle-exceptions' first argument needs to be a symbol"))
    (define var-ref [])
    (compile-let-block
      ctx T gtx
      (.AM gtx [[(@1 args) nil]])
      (lambda (ctx T gtx)
        (.AM gtx
             ['#s1#handle-exceptions
              (T ctx (@1 args))
              (T ctx (@2 args))
              (s1-begin T ctx (drop args 3))])))))
;----------------------------------------------------------------------------

(add-syntax
  'with-cleanup
  (lambda (ctx args T gtx)
    (unless (or (= (length args) 3)
                (= (length args) 4))
      (compiler-error gtx ctx "'with-cleanup' needs 2 or 3 arguments" args))
    (let ((clnup-cond-var-sym '*BKL-CLEANUP-COND*)
          (clnup-tag-var-sym  '*BKL-CLEANUP-TAG*)
          (clnup-val-var-sym  '*BKL-CLEANUP-VAL*))
      (compile-let-block
        ctx T gtx
        (.AM gtx [[clnup-cond-var-sym nil]
                  [clnup-tag-var-sym  nil]
                  [clnup-val-var-sym  nil]])
        (lambda (ctx T gtx)
          (define continuation-check
            (T ctx ['cond
                    [['nil? clnup-cond-var-sym] nil]
                    [['= clnup-cond-var-sym 1] ['return-from*
                                                clnup-tag-var-sym
                                                clnup-val-var-sym]]
                    [['= clnup-cond-var-sym 2] ['return
                                                clnup-val-var-sym]]]))
          (if (= (length args) 3)
            ['#s1#with-cleanup
             [(T ctx clnup-cond-var-sym)
              (T ctx clnup-tag-var-sym)
              (T ctx clnup-val-var-sym)
              continuation-check]
             [(T ctx (@1 args))]
             (T ctx (@2 args))]
            ['#s1#with-cleanup
             [(T ctx clnup-cond-var-sym)
              (T ctx clnup-tag-var-sym)
              (T ctx clnup-val-var-sym)
              continuation-check]
             [(T ctx (@2 args)) (T ctx (@1 args))]
             (T ctx (@3 args))]))))))
;----------------------------------------------------------------------------

(add-syntax
  'block
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (compiler-error gtx ctx
                      "'block' needs at least 2 arguments (the tag and an expression)"
                      args))
    (unless (or (symbol? (@1 args))
                (keyword? (@1 args)))
      (compiler-error gtx ctx
                      "'block' tag needs to be either a symbol or a keyword"
                      args))
    ['#s1#block (@1 args)
     (s1-begin T ctx (drop args 2))]))
;----------------------------------------------------------------------------

(add-syntax
  'return-from*
  (lambda (ctx args T gtx)
    (unless (= (length args) 3)
      (compiler-error gtx ctx
                      "'return-from' needs exactly 2 arguments the tag and the value"
                      args))
    (append '#s1#return-from [(T ctx (@1 args)) (T ctx (@2 args))])))
;----------------------------------------------------------------------------

(add-syntax
  'return-from
  (lambda (ctx args T gtx)
    (unless (= (length args) 3)
      (compiler-error gtx ctx
                      "'return-from' needs exactly 2 arguments the tag and the value"
                      args))
    (unless (or (symbol? (@1 args))
                (keyword? (@1 args)))
      (compiler-error gtx ctx
                      "'return-from' tag needs to be either a symbol or a keyword"
                      args))
    (append '#s1#return-from [(.S1-T-Q gtx ctx (@1 args)) (T ctx (@2 args))])))
;----------------------------------------------------------------------------

(add-syntax
  'lambda
  (lambda (ctx args T gtx)
    (define lambda-name nil)
    (when (not (nil? (lambda-name: ctx)))
      (set! lambda-name (lambda-name: ctx))
      (set! ctx (assign ctx [lambda-name: nil])))
    (define is-coroutine?
      (if (eqv? (@1 args) coroutine:)
        (begin
          (set! args (drop args 2))
          #t)
        (begin
          (set! args (drop args 1))
          #f)))
    (unless (> (length args) 1)
      (compiler-error gtx ctx "'lambda' needs more than 1 argument" args))
    (define lambda-params
      (parse-lambda-params
        (@0 args)
        (lambda (msg a)
          (compiler-error gtx ctx (str "'lambda' parameter error: " msg) a))))
    (let ((new-env {" PARENT "         (env: ctx)
                    " LAMBDA-UPV "     {}})
          (new-args [])
          (va-arg nil)
          (let-vars [])
          (new-ctx (assign ctx [env:      new-env
                                let-vars: let-vars])))
      (do-each (s (args: lambda-params))
        (let ((new-var-name (gtx-gensym gtx s)))
          (push! new-args new-var-name)
          (@!s new-env [var: new-var-name s])))
      (unless (nil? (varargs-param: lambda-params))
        (let ((va-arg-name  (varargs-param: lambda-params))
              (new-var-name (gtx-gensym gtx va-arg-name)))
          (@!va-arg-name new-env [var: new-var-name va-arg-name])
          (set! va-arg new-var-name)))
      (let ((compiled-body
              (.AM gtx (s1-begin T new-ctx (drop args 1))))
            (lambda-upv
              (if (> (length (@" LAMBDA-UPV " new-env)) 0)
                (keys-in-map (@" LAMBDA-UPV " new-env))
                nil))
            (defined-upvalues (if (found-upv-in-env? new-env)
                                (only-in-first
                                  (upvalues-in-env new-env)
                                  new-args)
                                []))
            (non-upv-let-vars (only-in-first let-vars defined-upvalues))
            (lambda-body (if (found-upv-in-env? new-env)
                           (let ((upv-body ['#s1#create-upv
                                            lambda:
                                            (upvalues-in-env new-env)
                                            compiled-body]))
                             (if (> (length defined-upvalues) 0)
                               [['#s1#let defined-upvalues upv-body]]
                               [upv-body]))
                           [compiled-body])))
        (unless (empty? non-upv-let-vars)
          (set! lambda-body [['#s1#let non-upv-let-vars (first lambda-body)]]))
        (append
          '#s1#lambda
          (.AM gtx (if (nil? va-arg)
                     [[lambda-name new-args nil    lambda-upv is-coroutine?]]
                     [[lambda-name new-args va-arg lambda-upv is-coroutine?]]))
          lambda-body)))))
;----------------------------------------------------------------------------

(add-syntax
  'let
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (compiler-error
        gtx ctx "'let' needs more than 1 argument" args))
    (let ((var-binds (@1 args)))
      (unless (list? var-binds)
        (compiler-error
          gtx ctx "'let' binding list needs to be a list" var-binds))
      (do-each (bind-pair var-binds)
        (unless (list? bind-pair)
          (compiler-error
            gtx ctx "'let' binding pair needs to be a list" bind-pair))
        (unless (= (length bind-pair) 2)
          (compiler-error
            gtx ctx "'let' binding pair needs exactly 2 elements" bind-pair))
        (unless (symbol? (@0 bind-pair))
          (compiler-error
            gtx ctx "'let' binding pair must contain a symbol as first element"
            bind-pair)))
      (compile-let-block
       ctx T gtx
       var-binds
       (lambda (ctx T gtx)
         (s1-begin T ctx (drop args 2)))))))
;----------------------------------------------------------------------------

(add-syntax
  'define
  (lambda (ctx args T gtx)
    (define is-root-env?
      (@" IS-ROOT-ENV " (env: ctx)))
    (define is-coroutine?
      (if (eqv? (@1 args) :coroutine)
        (begin
          (set! args (append 'define (drop args 2)))
          #true)
        #false))
    (case (type (@1 args))
      ((symbol) (unless (= (length args) 3)
                  (compiler-error
                    gtx ctx (str "'define' needs exactly 2 arguments if "
                                 "first is a symbol")
                    args))
                (let ((var-name (@1 args))
                      (var        nil)
                      (var-s1-sym nil))
                  (if is-root-env?
                    (begin
                      (set! var-s1-sym '#s1#glob-var)
                      (let ((glob-reg-idx (length (@" REGS " (env: ctx)))))
                        (push! (@" REGS " (env: ctx)) nil)
                        (set! var [glob-var: var-name glob-reg-idx])))
                    (begin
                      (set! var-s1-sym '#s1#var)
                      (let ((new-var-name (gtx-gensym gtx var-name)))
                        (push! (let-vars: ctx) new-var-name)
                        (set! var [var: new-var-name var-name]))))
                  (@!var-name (env: ctx) var)
                  ['#s1#set! (append var-s1-sym (drop var 1))
                   (T (assign ctx [lambda-name: var-name])
                      (@2 args))]))
      ((list) (unless (> (length args) 2)
                (compiler-error
                  gtx ctx (str "'define' for function define needs "
                               "at least 3 arguments")
                  args))
              (do-each (s (@1 args))
                (unless (symbol? s)
                  (compiler-error
                    gtx ctx (str "'define' for function requires the "
                                 "first argument be a list only "
                                 "of symbols")
                    (@1 args))))
              (let ((func-name      (@0 (@1 args)))
                    (var-s1-sym     nil)
                    (var            nil))
                (if is-root-env?
                  (begin
                    (set! var-s1-sym '#s1#glob-var)
                    (let ((glob-reg-idx (length (@" REGS " (env: ctx)))))
                      (push! (@" REGS " (env: ctx)) nil)
                      (set! var [glob-var: func-name glob-reg-idx])))
                  (begin
                    (set! var-s1-sym '#s1#var)
                    (let ((new-var-name (gtx-gensym gtx func-name)))
                      (push! (let-vars: ctx) new-var-name)
                      (set! var [var: new-var-name func-name]))))
                (@!func-name (env: ctx) var)
                ['#s1#set! (append var-s1-sym (drop var 1))
                 (T (assign ctx [lambda-name: func-name])
                    (.AM gtx
                         (if is-coroutine?
                           (append
                             'lambda
                             :coroutine
                             (.AM gtx [(drop (@1 args) 1)])
                             (drop args 2))
                           (append
                             'lambda
                             (.AM gtx [(drop (@1 args) 1)])
                             (drop args 2)))))]))
      (else
        (compiler-error gtx ctx "'define' unexpected first argument" args)))))
;----------------------------------------------------------------------------

(add-syntax
  'define-macro
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (compiler-error gtx ctx "'define-macro' needs at least 2 arguments" args))
    (define params (@1 args))
    (unless (list? params)
      (compiler-error
        gtx ctx "'define-macro' first argument needs to be a parameter list"
        params))
    (do-each (v params)
      (unless (symbol? v)
        (compiler-error
          gtx ctx "'define-macro' parameter list must consist only of symbols"
          params)))
    (define macro-name (first params))
    (displayln MACRO-EVAL: args)
    (define macro-func
      (eval (.AM gtx (append ['lambda (drop params 1)]
                             (drop args 2)))
            {}))
    (@!macro-name (env: ctx)
                  [macro: macro-func macro-name])
    (.AM gtx ['#s1#nil])))
;----------------------------------------------------------------------------

(define find-include-file
  (lambda (filename first-include-dir)
    (define filepath (str first-include-dir
                          (sys-path-separator)
                          filename))
    (if (file-exists? filepath)
        filepath
        (bkl-find-lib-file filename))))
;----------------------------------------------------------------------------

(define compile-include
  (lambda (ctx filename T gtx)
    (let ((include-file-path (find-include-file filename (include-dir: ctx)))
          (include-content (sys-slurp-file
                             include-file-path))
          (read-data       (read-str include-content
                                     include-file-path))
          (new-ctx (assign ctx
                           [include-dir:
                             (first (sys-path-split
                                      include-file-path))])))
      (with-cleanup
        (push! (meta-stack: gtx) [include-file-path 1])
        (pop! (meta-stack: gtx))
        (s1-begin T new-ctx read-data)))))
;----------------------------------------------------------------------------

(add-syntax
  'include
  (lambda (ctx args T gtx)
    (unless (= (length args) 2)
      (compiler-error gtx ctx "'include' needs exactly 1 argument" args))
    (compile-include ctx (@1 args) T gtx)))
;----------------------------------------------------------------------------

(add-syntax
  '$define!
  (lambda (ctx args T gtx)
     (unless (> (length args) 3)
       (compiler-error gtx ctx "'$define!' needs at least 3 arguments" args))
     (unless (list? (@2 args))
       (compiler-error
         gtx ctx "'$define!' second argument needs to be a list" args))
     (unless (> (length (@2 args)) 0)
       (compiler-error
         gtx ctx "'$define!' second argument list needs at least 1 symbol" args))
     (do-each (v (@2 args))
       (unless (symbol? v)
         (compiler-error gtx ctx
           "'$define!' parameter list may only contain symbols"
           (@2 args))))
    ['#s1#set method:
     ['#s1#data (first (@2 args))]
     (T ctx (@1 args))
     (T (assign ctx [lambda-name: (first (@2 args))])
        (.AM
          gtx
          (append
            'lambda
            (.AM gtx [(drop (@2 args) 1)])
            (drop args 3))))]))

;----------------------------------------------------------------------------

(bkl-set-doc! 'do-each
#q|
@iterative syntax (do-each (_val-sym_ _list-expr_) _sequence_)
@iterative syntax (do-each (_key-sym_ _value-sym_ _map-expr_) _sequence_)

The first version with just the _val-sym_ iterates over the value of
_list-expr_, which must either be a list or a map,
binding the variable _val-sym_ to the current item (list element or map value)
and executing _sequence_ for each item.

    (let ((non-zero-vals []))
        (do-each (v [ 0 322 0 493 0 12 212 3 40 ])
            (when (not (zero? v))
                (push! non-zero-vals v)))
        non-zero-vals)
    ;=> (322 493 12 212 3 40)

The second form with _key-sym_ iterates over like the first, except that
_key-sym_ is bound to the list index or the map key for the corresponding
value.

    (let ((keys []) (vals []))
        (do-each (k v { :a 10 :b 20 :c 30 })
            (push! keys k)
            (push! vals v))
        keys)
    ;=> (:a :b :c)
|)

(add-syntax
  'do-each
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (compiler-error gtx ctx "'do-each' needs at least 2 arguments" args))
    (define iter-desc (@1 args))
    (unless (list? iter-desc)
      (compiler-error gtx ctx
        (str "first argument to 'do-each' "
             "needs to be an iteration description list")
        args))
    (when (< (length iter-desc) 2)
      (compiler-error gtx ctx
        "iteration description must be at least 2 elements long"
        iter-desc))
    (when (> (length iter-desc) 3)
      (compiler-error gtx ctx
        "iteration description too long (2 or 3 elements allowed)"
        iter-desc))
    (unless (symbol? (@0 iter-desc))
      (compiler-error gtx ctx
        "key bind name of iteration description must be a symbol"
        iter-desc));
    (define obj-atom (@1 iter-desc))
    (if (eqv? (length iter-desc) 3)
      (begin
        (define obj-atom (@2 iter-desc))
        (unless (symbol? (@1 iter-desc))
          (compiler-error
            gtx ctx
            "value bind name of iteration description must be a symbol"
            iter-desc))
        (define obj (T ctx obj-atom))
        (compile-let-block
          ctx T gtx
          (.AM gtx [[(@0 iter-desc) nil]
                    [(@1 iter-desc) nil]])
          (lambda (ctx T gtx)
            ['#s1#do-each
             [(T ctx (@1 iter-desc))
              (T ctx (@0 iter-desc))]
             obj
             (s1-begin T ctx (drop args 2))])))
      (begin
        (define obj (T ctx obj-atom))
        (compile-let-block
          ctx T gtx
          (.AM gtx [[(@0 iter-desc) nil]])
          (lambda (ctx T gtx)
            ['#s1#do-each
             [(T ctx (@0 iter-desc))]
             obj
             (s1-begin T ctx (drop args 2))]))))))
;----------------------------------------------------------------------------

(add-syntax
  'while
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (compiler-error
        gtx ctx "'while' needs at least 2 arguments (test and body)" args))
    ['#s1#while
     (T ctx (@1 args))
     (s1-begin T ctx (drop args 2))]))
;----------------------------------------------------------------------------

(add-syntax
  'for
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (compiler-error
        gtx ctx "'for' needs at least 2 arguments (iterator desc and body)"
        args))
    (let ((iter-desc (@1 args)))
      (unless (or (= (length iter-desc) 3)
                  (= (length iter-desc) 4))
        (compiler-error
          gtx ctx "'for' iteration description needs 3 or 4 elements"
          iter-desc))
      (unless (symbol? (@0 iter-desc))
        (compiler-error
          gtx ctx "'for' iteration description needs a symbol as first elemetn"
          iter-desc))
      (compile-let-block
        ctx T gtx
         (.AM gtx [[(@0 iter-desc) (@1 iter-desc)]])
         (lambda (ctx T gtx)
           ['#s1#for [(T ctx (@2 iter-desc))
                     (T ctx (if (nil? (@3 iter-desc))
                              1
                              (@3 iter-desc)))
                     (T ctx (@0 iter-desc))]
            (s1-begin T ctx (drop args 2))])))))
;----------------------------------------------------------------------------

(add-syntax
  'do
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (compiler-error
        gtx ctx "'do' needs at least 2 arguments (iterator binds, test and body)"
        args))
    (unless (list? (@1 args))
      (compiler-error
        gtx ctx "'do' first argument is not a list (iterator binds)"))
    (unless (list? (@2 args))
      (compiler-error
        gtx ctx "'do' second argument is not a list (test)"))
    (unless (> (length (@2 args)) 1)
      (compiler-error
        gtx ctx "'do' test needs a test expression and a return value expression"
        (@2 args)))
    (let ((iter-descs           (@1 args))
          (let-binds            [])
          (test-expr            (@0 (@2 args)))
          (test-end-block       (drop (@2 args) 1)))
      (do-each (iter-bind iter-descs)
        (unless (or (= (length iter-bind) 2)
                    (= (length iter-bind) 3))
          (compiler-error
            gtx ctx "'do' bad iterator bind, has not 3 elements" iter-bind))
        (unless (symbol? (@0 iter-bind))
          (compiler-error
            gtx ctx "'do' first element of iteration binding needs to be a symbol"
            iter-bind))
        (push! let-binds [(@0 iter-bind) (@1 iter-bind)]))
      (compile-let-block
        ctx T gtx
        (.AM gtx let-binds)
        (lambda (ctx T gtx)
          (do-each (bind let-binds)
            (@!0 bind (T ctx (@0 bind))))
          (define step-exprs (.AM gtx []))
          (let ((i 0))
            (do-each (bind let-binds)
              (define iter (@i iter-descs))
              (define step
                (if (nil? (@2 iter))
                  (@0 bind)
                  (T ctx (@2 iter))))
              (push! step-exprs
                     (DI! iter ['#s1#set! (@0 bind) step]))
              (set! i (+ i 1))))
          (if (> (length step-exprs) 1)
            (unshift! step-exprs '#s1#begin)
            (set! step-exprs (first step-exprs)))
          ['#s1#do
           (T ctx test-expr)
           (s1-begin T ctx test-end-block)
           step-exprs
           (s1-begin T ctx (drop args 3))])))))
;----------------------------------------------------------------------------

(add-syntax
  '.
  (lambda (ctx args T gtx)
    (unless (> (length args) 2)
      (compiler-error
        gtx ctx "method call needs at least 2 arguments (method & object)"
        args))
    (let ((method-name (@1 args))
          (obj         (@2 args))
          (m-args      (drop args 3)))
      (unless (or (symbol? method-name)
                  (keyword? method-name)
                  (string? method-name))
        (set! method-name (T ctx method-name)))
      (append
        '#s1#method-call
        [method-name]
        [(T ctx obj)]
        (.AM gtx (map (lambda (v) (T ctx v)) m-args))))))
;----------------------------------------------------------------------------

(add-syntax
  'or
  (lambda (ctx args T gtx)
    (unless (> (length args) 1)
      (compiler-error gtx ctx "'or' needs at least one argument" args))
    (define tmp-var (gtx-gentmpsym gtx 'or))
    (define operand (@1 args))
    (define false-v (T ctx #f))
    (define build-sub-tree
      (lambda (rest-ops)
        (let ((next-rest-ops (drop rest-ops 1))
              (operand       (first rest-ops)))
          ['#s1#begin
           ['#s1#set! tmp-var (T ctx operand)]
           (.AM
             gtx
             (if (> (length next-rest-ops) 0)
               ['#s1#if tmp-var tmp-var (build-sub-tree next-rest-ops)]
               ['#s1#if tmp-var tmp-var false-v]))])))

    (compile-let-block
      ctx T gtx
      (.AM gtx [[tmp-var operand]])
      (lambda (ctx T gtx)
        (unless (list? tmp-var)
          (set! tmp-var (T ctx tmp-var)))
        (.AM gtx
             (if (> (length args) 2)
               ['#s1#if tmp-var tmp-var (build-sub-tree (drop args 2))]
               ['#s1#if tmp-var tmp-var false-v]))))))
;----------------------------------------------------------------------------

(add-syntax
  'and
  (lambda (ctx args T gtx)
    (unless (> (length args) 1)
      (compiler-error gtx ctx "'and' needs at least one argument" args))
    (define tmp-var (gtx-gentmpsym gtx 'and))
    (define operand (@1 args))
    (define false-v (T ctx #f))
    (define build-sub-tree
      (lambda (rest-ops)
        (let ((next-rest-ops (drop rest-ops 1))
              (operand       (first rest-ops)))
          ['#s1#begin
           ['#s1#set! tmp-var (T ctx operand)]
           (.AM
             gtx
             (if (> (length next-rest-ops) 0)
               ['#s1#if tmp-var (build-sub-tree next-rest-ops) false-v]
               ['#s1#if tmp-var tmp-var false-v]))])))
    (compile-let-block
      ctx T gtx
      (.AM gtx [[tmp-var operand]])
      (lambda (ctx T gtx)
        (unless (list? tmp-var)
          (set! tmp-var (T ctx tmp-var)))
        (.AM gtx
             (if (> (length args) 2)
               ['#s1#if tmp-var (build-sub-tree (drop args 2)) false-v]
               ['#s1#if tmp-var tmp-var false-v]))))))
;----------------------------------------------------------------------------

(add-syntax
  'cond
  (lambda (ctx arg T gtx)
    ; TODO: For 'case' and 'cond' it would be useful to extract the
    ;       debug meta info from the clauses, so we can have more 
    ;       precise error messages!
    (define else-clause nil)
    (define out ['#s1#cond])
    (unless (> (length arg) 1)
      (compiler-error gtx ctx "'cond' clause must have at least one clause"
                      arg))
    (do-each (clause (drop arg 1))
      (unless (list? clause)
        (compiler-error gtx ctx "'cond' has an improper clause (not a list)"
                        clause))
      (when (< (length clause) 2)
        (compiler-error
          gtx ctx (str "'cond' clauses must at least contain a test "
                       "expression and result expression")
          clause))
      (if (eqv? (@0 clause) 'else)
        (begin
          (when else-clause
            (compiler-error
              gtx ctx "'cond' must not have more than one 'else' clause" clause))
          (set! else-clause clause))
        (push!
          out
          (if (eqv? (@1 clause) '=>)
            (let ((tmp-var (gtx-gentmpsym gtx 'cond)))
              (compile-let-block
                ctx T gtx
                (.AM gtx [[tmp-var (first clause)]])
                (lambda (ctx T gtx)
                  (set! tmp-var (T ctx tmp-var))
                  [clause:
                    tmp-var
                    (DI! (@2 clause)
                         ['#s1#apply
                          (T ctx (@2 clause))
                          [tmp-var]])])))
            [clause:
              (T ctx (first clause))
              (DI! clause (s1-begin T ctx (drop clause 1)))]))))
    (if else-clause
      (push! out [else: (s1-begin T ctx (DI! else-clause (drop else-clause 1)))])
      (push! out [else: (T ctx nil)]))
    out))
;----------------------------------------------------------------------------

(add-syntax
  'case
  (lambda (ctx arg T gtx)
    ; TODO: For 'case' and 'cond' it would be useful to extract the
    ;       debug meta info from the clauses, so we can have more 
    ;       precise error messages!
    (define else-clause nil)
    (when (< (length arg) 3)
      (compiler-error gtx ctx "'case' needs at least 2 arguments" arg))
    (let ((all-values {}))
      (do-each (clause (drop arg 2))
        (if (eqv? (first clause) 'else)
          (begin
            (when else-clause
              (compiler-error gtx ctx "'case' duplicated else clause" clause))
            (set! else-clause clause))
          (begin
            (when (not (list? (first clause)))
              (compiler-error
                gtx ctx "'case' clause first element is not a list" clause))
            (do-each (element (first clause))
              (if (@element all-values)
                (compiler-error
                  gtx ctx "'case' with duplicate value" element))
              (@!element all-values #t)))))
    (let ((key-value (@1 arg))
          (tmp-var (gtx-gentmpsym gtx 'case)))
      (compile-let-block
        ctx T gtx
        (.AM gtx [[tmp-var key-value]])
        (lambda (ctx T gtx)
          (set! tmp-var (T ctx tmp-var))
          (define out-cond ['#s1#cond])
          (do-each (clause (drop arg 2))
            (unless (eqv? (first clause) 'else)
              (if (eqv? (@1 clause) '=>)
                (begin
                  (do-each (element (first clause))
                    (begin
                      (push! out-cond
                             [clause:
                               (DI!
                                 (first clause)
                                 ['#s1#eqv tmp-var (.S1-T-Q gtx ctx element)])
                               (DI! clause
                                    ['#s1#apply
                                     (T ctx (@2 clause))
                                     [tmp-var]])]))))
                (let ((expr-block
                        (s1-begin T ctx (DI! clause (drop clause 1)))))
                  (do-each (element (first clause))
                    (begin
                      (push! out-cond
                             [clause:
                               ['#s1#eqv tmp-var (.S1-T-Q gtx ctx element)]
                               expr-block])))))))
          (when else-clause
            (push! out-cond
              (if (eqv? (@1 else-clause) '=>)
                [else: (DI!
                         else-clause
                         ['#s1#apply
                          (T ctx (@2 else-clause))
                          [tmp-var]])]
                [else: (s1-begin T ctx (DI!
                                         else-clause
                                         (drop else-clause 1)))])))
          out-cond))))))
;----------------------------------------------------------------------------

(add-syntax
  'define-library
  (lambda (ctx arg T gtx)
    (unless (@" LIBRARIES " (root-env: gtx))
      (@!" LIBRARIES " (root-env: gtx) {}))
    (define LIBRARIES (@" LIBRARIES " (root-env: gtx)))
    (unless (list? (@1 arg))
      (compiler-error
        gtx ctx "'define-library' library name needs to be a list" (@1 arg)))
    (define lib-name (apply str-join "-" (@1 arg)))
    (define lib-root-env {" IS-ROOT-ENV " #t " REGS " []})
    (define export-list [])
    (do-each (decl (drop arg 2))
      (unless (list? decl)
        (compiler-error
          gtx ctx "'define-library' invalid library declaration" decl))
      (case (@0 decl)
        ((export)
         (do-each (ex (drop decl 1))
           (push! export-list ex)))
        ((import)
         (let ((import-lib-name (apply str-join "-" (@1 decl))))
           (if (eqv? import-lib-name "bukalisp-base")
             (begin
               (init-root-env lib-root-env)))))
        ((begin)
         (.lib-compiler gtx lib-name (drop decl 1) lib-root-env #f))))
    (define exported-values {})
    (do-each (ex export-list)
      (let ((exp-var (@ex lib-root-env)))
        (unless exp-var
          (compiler-error
            gtx ctx "'define-library' can't export undefined binding" ex))
        (if (eqv? (@0 exp-var) glob-var:)
          (let ((value (get-root-env-var lib-root-env ex)))
            (@!ex exported-values [glob-var: ex value]))
          (@!ex exported-values exp-var))))
    (@!lib-name LIBRARIES [lib-root-env exported-values])
    ['#s1#data exported-values]))
;----------------------------------------------------------------------------

(add-syntax
  'import
  (lambda (ctx arg T gtx)
    (unless (@" LIBRARIES " (root-env: gtx))
      (@!" LIBRARIES " (root-env: gtx) {}))
    (define LIBRARIES (@" LIBRARIES " (root-env: gtx)))
    (do-each (import-set (drop arg 1))
      (let ((library-name (apply str-join "-" import-set))
            (module-lib   (when (eqv? (@0 import-set) 'module)
                            (@(@1 import-set) (bkl-get-vm-modules))))
            (lib          (@library-name LIBRARIES)))
        (if module-lib
          (do-each (sym val module-lib)
            (set-root-env-var
              (root-env: gtx)
              (string->symbol
                (str (@1 import-set)
                     "-"
                     (symbol->string sym)))
              (@2 val)))
          (begin
            (unless lib
              (let ((library-file
                      (str (apply str-join
                                  (sys-path-separator)
                                  import-set)
                           ".bkl")))
                (compile-include ctx library-file T gtx)
                (set! lib (@library-name LIBRARIES))
                (unless lib
                  (compiler-error
                    gtx ctx "'import' library not found, also not defined in library file"
                    [library-name library-file]))))
            (do-each (sym var (@1 lib))
              (if (eqv? (@0 var) glob-var:)
                (set-root-env-var (root-env: gtx)
                                  sym
                                  (@2 var))
                (@!sym (root-env: gtx) var)))))))
    ['#s1#data nil]))
;----------------------------------------------------------------------------

(add-syntax
  'eval
  (lambda (ctx arg T gtx)
    (when (> (length arg) 3)
      (compiler-error gtx ctx "Too many arguments to 'eval'" arg))
    (when (< (length arg) 2)
      (compiler-error gtx ctx "Too few arguments to 'eval'" arg))
    (if (= (length arg) 2)
      ['#s1#eval (T ctx (@1 arg))]
      ['#s1#eval (T ctx (@1 arg)) (T ctx (@2 arg))])))
;----------------------------------------------------------------------------
