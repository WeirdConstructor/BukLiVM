(define make-local-env
  (lambda ()
    (let ((self      {})
          (env-stack [])
          (env-map   {}))

      (define recursive-lookup
       (lambda (sym idx)
         (displayln s: sym i: idx)
         (if (= idx 0)
           (let ((v (@sym env-map)))
             (displayln env-map sym v)
             (if (nil? v)
               (if (not (empty? env-stack))
                 (recursive-lookup sym (length env-stack))
                 nil)
               {var: v
                idx: idx
                env: env-map
                top: (= (length env-stack) 0)}))
           (let ((cur-env   (@(- idx 1) env-stack))
                 (v         (@sym cur-env)))
             (if (nil? v)
               (if (> idx 1)
                 (recursive-lookup sym (- idx 1))
                 nil)
               {var: v
                env: cur-env
                idx: idx
                top: (= idx 1)})))))

      ($define! self (here-defined-upvalues)
        ($" UPVALUES " env-map))

      ($define! self (set-here-defined-upvalue sym sub-env-map var)
        (when (nil? ($" UPVALUES " sub-env-map))
          ($!" UPVALUES " sub-env-map {}))
        (@!sym ($" UPVALUES " sub-env-map) var))

      ($define! self (set sym val)
        (@!sym env-map val))

      ($define! self (lookup sym)
        (recursive-lookup sym 0))

      ($define! self (push)
        (push! env-stack env-map)
        (set! env-map {}))

      ($define! self (pop)
        (set! env-map (pop! env-stack))))))

;(define l (make-local-env))
;(.set l 'f 444)
;(.set l 'x 123)
;(.push l)
;(.set l 'x 333)
;(displayln (.lookup l 'x))
;(displayln (.lookup l 'f))
;(.pop l)
;(displayln (.lookup l 'x))
;(displayln (.lookup l 'f))
